test_dict = [{'name': 'atl_sound_exchange', 'files': [{'name': 'error.rs', 'language': 'Rust', 'contents': 'use argon2::Error as ArgonError;\nuse tracing::*;\nuse warp::{\n    filters::{body::BodyDeserializeError, cors::CorsForbidden},\n    http::StatusCode,\n    reject::Reject,\n    Rejection, Reply,\n};\n\n#[derive(Debug)]\npub enum Error {\n    // when rust can\'t parse an int out of a string we get a ParseIntError\n    ParseError(std::num::ParseIntError),\n    MissingParameters,\n    DatabaseQueryError(sqlx::Error),\n    WrongPassword,\n    ArgonLibraryError(ArgonError),\n    GraphingError,\n}\n\n// Let\'s get some custom error messages going to disambiguate a bit\nimpl std::fmt::Display for Error {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        match *self {\n            // ref???\n            Error::ParseError(ref err) => write!(f, "Cannot parse parameter: {}", err),\n            Error::MissingParameters => write!(f, "Missing parameter"),\n            // Error::ArtistNotFound => write!(f, "Artist not found"),\n            Error::DatabaseQueryError(_) => write!(f, "Query could not be executed"),\n            Error::WrongPassword => write!(f, "Wrong password"),\n            Error::ArgonLibraryError(_) => write!(f, "Cannot verify password"),\n            Error::GraphingError => write!(f, "Unable to produce graph"),\n        }\n    }\n}\n\n// marker trait so that\'s why the body\'s empty\nimpl Reject for Error {}\n\n// TODO:\n// Cache error and return more user friendly error message\npub async fn return_error(r: Rejection) -> Result<impl Reply, Rejection> {\n    // r.find() allows us to search for specific rejections\n    if let Some(Error::DatabaseQueryError(e)) = r.find() {\n        event!(Level::ERROR, "Database query error");\n        match e {\n            sqlx::Error::Database(err) => {\n                // Check if database error code is \'account already exists\' code\n                if err.code().unwrap().parse::<i32>().unwrap() == 23505 {\n                    Ok(warp::reply::with_status(\n                        "Account already exists".to_string(),\n                        StatusCode::UNPROCESSABLE_ENTITY,\n                    ))\n                } else {\n                    Ok(warp::reply::with_status(\n                        "Cannot update data".to_string(),\n                        StatusCode::UNPROCESSABLE_ENTITY,\n                    ))\n                }\n            }\n            _ => Ok(warp::reply::with_status(\n                "Cannot update data".to_string(),\n                StatusCode::UNPROCESSABLE_ENTITY,\n            )),\n        }\n    } else if let Some(error) = r.find::<CorsForbidden>() {\n        Ok(warp::reply::with_status(\n            error.to_string(),\n            StatusCode::FORBIDDEN,\n        ))\n    } else if let Some(error) = r.find::<BodyDeserializeError>() {\n        Ok(warp::reply::with_status(\n            error.to_string(),\n            StatusCode::UNPROCESSABLE_ENTITY,\n        ))\n    } else if let Some(Error::WrongPassword) = r.find() {\n        event!(Level::ERROR, "Entered wrong password");\n        Ok(warp::reply::with_status(\n            "Wrong E-Mail/Password combination".to_string(),\n            StatusCode::UNAUTHORIZED,\n        ))\n    } else {\n        Ok(warp::reply::with_status(\n            "Route not found".to_string(),\n            StatusCode::NOT_FOUND,\n        ))\n    }\n}\n'}, {'name': 'main.rs', 'language': 'Rust', 'contents': '#![warn(clippy::all)]\n\nuse warp::{http::Method, Filter};\n\nuse crate::routes::artist_routes::get_artists;\nuse sqlx;\nuse tracing_subscriber::fmt::format::FmtSpan;\n\nmod error;\nmod routes;\nmod store;\nmod types;\n\n#[tokio::main]\nasync fn main() -> Result<(), error::Error> {\n    // TODO: Revisit tracing, need to make sure logs are outputted to debug.log file\n    // Console logs work, need to work on logging to file\n    // Also, we should probably avoid logging whole artist json file, makes logs much less readable\n\n    // https://docs.rs/tracing-subscriber/0.3.1/tracing_subscriber/layer/idnex.html\n    // https://stackoverflow.com/questions/70013172/how-to-use-the-tracing-library\n\n    // console logs\n    // let stdout_log = tracing_subscriber::fmt::layer().pretty();\n\n    /*\n    // logs events to a file\n    let log_file = match File::open("debug.log") {\n        Ok(log_file) => log_file,\n        Err(err) => panic!("Error: {:?}", err),\n    };\n    let debug_log = tracing_subscriber::fmt::layer().with_writer(Arc::new(log_file));\n\n    // A layer that collects metrics using specific events\n    let metrics_layer = /* ... */ filter::LevelFilter::INFO;\n\n    tracing_subscriber::registry()\n        .with(\n            stdout_log\n                // Add an \'INFO\' filter to the stdout logging layer\n                .with_filter(filter::LevelFilter::INFO)\n                // Combine the filtered \'stdout_log\' layer with the \'debug_log\' layer, producing a new \'Layered\' layer\n                .and_then(debug_log)\n                // Add a filter to *both* layers that rejects spans and events whose targets start with \'metrics\'\n                .with_filter(filter::filter_fn(|metadata| {\n                    !metadata.target().starts_with("metrics")\n                })),\n        )\n        .with(\n            // Add a filter to the metrics label that *only* enables events whose targets start with \'metrics\'\n            metrics_layer.with_filter(filter::filter_fn(|metadata| {\n                metadata.target().starts_with("metrics")\n            })),\n        )\n        .init();\n    */\n\n    // global log collector configured by RUST_LOG environmental variable\n    let log_filter = std::env::var("RUST_LOG")\n        // default log level\n        .unwrap_or_else(|_| "atl_sound_exchange=info,warp=error".to_owned());\n\n    // If we need to add a username and password, the link takes the structure:\n    // "postgres://username:password@localhost:port/db_name"\n    let store = store::Store::new("postgres://localhost:5432/atlse").await;\n    sqlx::migrate!("./src/migrations")\n        .run(&store.clone().connection)\n        .await\n        .expect("Cannot run migration");\n    let store_filter = warp::any().map(move || store.clone());\n\n    // Subscriber: receives all internal log and tracing events and decides what to do with them\n    tracing_subscriber::fmt()\n        // Use the log filter we built above to determine which traces to record\n        .with_env_filter(log_filter)\n        // Record an event when each span closes. This can be used to time our routes\' durations\n        .with_span_events(FmtSpan::CLOSE)\n        .init();\n\n    // Cross-Origin Resource Sharing (https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)\n    // "an HTTP-header based mechanism that allows a server to indicate any origins other than its\n    // own from which a browser should permit loading resources"\n    let cors = warp::cors()\n        .allow_any_origin()\n        .allow_header("content-type")\n        .allow_methods(&[Method::PUT, Method::DELETE, Method::GET, Method::POST]);\n\n    // What is a filter?\n    // Each HTTP requeset runs through the filters we setup and adds or modifies the data along the\n    // way\n    //\n    // Filters allow us to pass around state and return copies of the object we pass around to more than one route handler\n\n    let registration = warp::post()\n        .and(warp::path("registration"))\n        .and(warp::path::end())\n        .and(store_filter.clone())\n        .and(warp::body::json())\n        .and_then(routes::authentication::register);\n\n    // to do: allow requesting a single artist via an id\n    // parse url as in update_artist but instead of updating the artist in the hashmap, return it\n    let get_artists = warp::get()\n        .and(warp::path("artists"))\n        .and(warp::path::end())\n        .and(warp::query())\n        .and(store_filter.clone())\n        .and_then(get_artists)\n        .with(warp::trace(|info| {\n            tracing::info_span!(\n                "get_artists request",\n                // % sigil indicates the value should be recorded using its fmt::Display implementation\n                method = %info.method(),\n                path = %info.path(),\n                id = %uuid::Uuid::new_v4(),\n            )\n        }));\n\n    // It seems accepting all POST requests for artists would be a vulnerability\n    // We will want to add them internally, instead of allowing users to make POST requests\n    // and add random artists via cURL. Here\'s the code anyways, but it\'ll remain commented\n    // out for now, until I figure out how to only accept with authentication\n    /*\n    let add_artist = warp::post()\n        .and(warp::path("artists"))\n        .and(warp::path::end())\n        .and(store_filter.clone())\n        .and(warp::body::json())\n        .and_then(add_artist);\n    */\n\n    // PUT requests get same status as POST requests ^^^ for now\n    /* let update_artist = warp::put()\n        .and(warp::path("artists"))\n        // add parameters here so filter gets triggered for a particular artist (e.g. artist/000001)\n        .and(warp::path::param::<i32>())\n        .and(warp::path::end())\n        // add store to this route so we can pass it to route handler later\n        .and(store_filter.clone())\n        // extract JSON body\n        .and(warp::body::json())\n        .and_then(update_artist);\n    */\n\n    // DELETE requests get the same status as POST & PUT requests ^^^ for now\n    /* let delete_artist = warp::delete()\n        .and(warp::path("artists"))\n        .and(warp::path::param::<i32>())\n        .and(warp::path::end())\n        .and(store_filter.clone())\n        .and_then(delete_artist);\n    */\n\n    let login = warp::post()\n        .and(warp::path("login"))\n        .and(warp::path::end())\n        .and(store_filter.clone())\n        .and(warp::body::json())\n        .and_then(routes::authentication::login);\n\n    // defining http routes to try\n    // recover = error handling filter, fetches every prev rejection and check\n    // which HTTP message we need to send back\n    let routes = get_artists\n        // .or(update_artist)\n        // .or(add_artist)\n        // .or(delete_artist)\n        .or(registration)\n        .or(login)\n        .with(cors)\n        // log incoming requests as well\n        .with(warp::trace::request())\n        .recover(error::return_error);\n\n    // start the server and pass the route filter to it\n    Ok(warp::serve(routes).run(([127, 0, 0, 1], 3030)).await)\n}\n'}, {'name': 'store.rs', 'language': 'Rust', 'contents': 'use anyhow::Result;\nuse parking_lot::RwLock;\nuse sqlx::{\n    postgres::{PgPool, PgPoolOptions, PgRow},\n    Row,\n};\nuse std::sync::Arc;\nuse tracing::*;\nuse serde_json::value::Value as json;\nuse chrono::NaiveDate;\n// use crate::types::artist::genre;\nuse crate::error::Error;\nuse crate::types::{\n    account::{Account, AccountID},\n    artist::{Artist, ArtistID, NewArtist, Metric},\n};\n\n\n// Store holds the database connection and is passed to the route handlers\n#[derive(Clone, Debug)]\npub struct Store {\n    pub connection: PgPool,\n}\n\nimpl Store {\n    pub async fn new(db_url: &str) -> Self {\n        let db_pool = match PgPoolOptions::new()\n            .max_connections(5)\n            .connect(db_url)\n            .await\n        {\n            Ok(pool) => pool,\n            Err(_) => panic!("Couldn\'t establish DB connection!"),\n        };\n\n        Store {\n            connection: db_pool,\n        }\n    }\n\n    pub async fn add_account(self, account: Account) -> Result<bool, Error> {\n        match sqlx::query("INSERT INTO accounts (email, password) VALUES ($1, $2)")\n            .bind(account.email)\n            .bind(account.password)\n            .execute(&self.connection)\n            .await\n        {\n            Ok(_) => Ok(true),\n            Err(error) => {\n                tracing::event!(\n                    tracing::Level::ERROR,\n                    code = error\n                        .as_database_error()\n                        .unwrap()\n                        .code()\n                        .unwrap()\n                        .parse::<i32>()\n                        .unwrap(),\n                    db_message = error.as_database_error().unwrap().message(),\n                    constraint = error.as_database_error().unwrap().constraint().unwrap()\n                );\n                Err(Error::DatabaseQueryError(error))\n            }\n        }\n    }\n\n    pub async fn get_account(self, email: String) -> Result<Account, Error> {\n        match sqlx::query("SELECT * from accounts where email = $1")\n            .bind(email)\n            .map(|row: PgRow| Account {\n                id: Some(AccountID(row.get("id"))),\n                email: row.get("email"),\n                password: row.get("password"),\n            })\n            .fetch_one(&self.connection)\n            .await\n        {\n            Ok(account) => Ok(account),\n            Err(error) => {\n                event!(Level::ERROR, "{:?}", error);\n                Err(Error::DatabaseQueryError(error))\n            }\n        }\n    }\n\n    // RELEVANT LINKS\n    // https://stackoverflow.com/questions/74150290/encode-arcrwlockserde-json-to-postgresql-jsonb?noredirect=1#comment130918088_74150290\n    // https://docs.rs/sqlx/0.6.2/sqlx/trait.Encode.html\n    // https://docs.rs/sqlx-core/0.6.2/src/sqlx_core/postgres/types/interval.rs.html#196\n\n        pub async fn add_artists(self, new_artist: NewArtist) -> Result<Artist, sqlx::Error> {\n            // Can we acquire the locks here before passing them to the query?\n            let unlocked_deezer = new_artist.deezer_data.read().read();\n            let unlocked_instagram = new_artist.instagram_data.read().read();\n            let unlocked_soundcloud = new_artist.soundcloud_data.read().read();\n            let unlocked_spotify = new_artist.spotify_data.read().read();\n            let unlocked_tiktok = new_artist.tiktok_data.read().read();\n            let unlocked_twitter = new_artist.twitter_data.read().read();\n            let unlocked_yt_channel = new_artist.yt_channel_data.read().read();\n            let unlocked_yt_artist = new_artist.yt_channel_data.read().read();\n            match sqlx::query("INSERT INTO artists (id, name, genre, socials, background, deezer, instagram, soundcloud, spotify, tiktok, twitter, yt_channel, yt_artist) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13) RETURNING id, name, genre, socials, background, deezer, instagram, soundcloud, spotify, tiktok, twitter, yt_channel, yt_artist")\n                .bind(new_artist.name)\n                .bind(new_artist.genre)\n                .bind(new_artist.socials)\n                .bind(new_artist.background)\n                .bind(unlocked_instagram)\n                .bind(unlocked_soundcloud)\n                .bind(unlocked_spotify)\n                .bind(unlocked_tiktok)\n                .bind(unlocked_twitter)\n                .bind(unlocked_yt_channel)\n                .bind(unlocked_yt_artist)\n                .map(|row: PgRow| Artist {\n                    id: ArtistID(row.get("id")),\n                    name: row.get("artist_name"),\n                    genre: row.get("genre"),\n                    socials: row.get("socials"),\n                    background: row.get("background"),\n                    deezer_data: Arc::new(RwLock::new(row.get("deezer"))),\n                    instagram_data: Arc::new(RwLock::new(row.get("instagram"))),\n                    soundcloud_data: Arc::new(RwLock::new(row.get("soundcloud"))),\n                    spotify_data: Arc::new(RwLock::new(row.get("spotify"))),\n                    tiktok_data: Arc::new(RwLock::new(row.get("tiktok"))),\n                    twitter_data: Arc::new(RwLock::new(row.get("twitter"))),\n                    yt_channel_data: Arc::new(RwLock::new(row.get("yt_channel"))),\n                    yt_artist_data: Arc::new(RwLock::new(row.get("yt_artist"))),\n                })\n                .fetch_one(&self.connection)\n                .await{\n                    Ok(artist) => Ok(artist),\n                    Err(e) => {\n                        event!(Level::ERROR, "{:?}, error");\n                        Err(Error::DatabaseQueryError(e))\n                    },\n                }\n        }\n    \n    // Pass limit and offset params to indicate if pagination is wanted by the client\n    pub async fn get_artists(self, limit: Option<i32>, offset: i32) -> Result<Vec<Artist>, Error> {\n        match sqlx::query("SELECT * from artists LIMIT $1 OFFSET $2")\n            // bind method substitutes variables (e.g. $1 -> limit)\n            // limit & offset = pagination params in postgreSQL\n            .bind(limit)\n            .bind(offset)\n            // using map to aggregate each row returned from  postgreSQL query into an Artist\n            // TODO: Buff up error handling here\n            .map(|row: PgRow| Artist {\n                id: ArtistID(row.get("id")),\n                name: row.get("artist_name"),\n                genre: row.get("genre"),\n                socials: row.get("socials"),\n                background: row.get("background"),\n                deezer_data: Arc::new(RwLock::new(row.get("deezer"))),\n                instagram_data: Arc::new(RwLock::new(row.get("instagram"))),\n                soundcloud_data: Arc::new(RwLock::new(row.get("soundcloud"))),\n                spotify_data: Arc::new(RwLock::new(row.get("spotify"))),\n                tiktok_data: Arc::new(RwLock::new(row.get("tiktok"))),\n                twitter_data: Arc::new(RwLock::new(row.get("twitter"))),\n                yt_channel_data: Arc::new(RwLock::new(row.get("yt_channel"))),\n                yt_artist_data: Arc::new(RwLock::new(row.get("yt_artist"))),\n            })\n            // Returns all artists found\n            .fetch_all(&self.connection)\n            .await\n        {\n            Ok(artists) => Ok(artists),\n            Err(e) => {\n                event!(Level::ERROR, "{:?}", e);\n                Err(Error::DatabaseQueryError(e))\n            }\n        }\n    }\n    // Should this function reside on Artist\'s Impl block or Store\'s impl block?\n    pub async fn get_metrics(metric: Metric, duration: (NaiveDate, NaiveDate)) -> Result<Arc<RwLock<json>>, Error> {\n        match sqlx::query("SELECT * from artists LIMIT $1 OFFSET $2")\n            .bind(limit)\n            .bind(offset)\n    }\n}\n'}, {'name': 'api_call.py', 'language': 'Python', 'contents': 'import spotify\nimport twitter\nimport instagram\nimport youtube_artist\nimport youtube_channel\nimport deezer\nimport soundcloud\nimport tiktok\nimport sys\n\napi_token = sys.argv[1]\nid = sys.argv[2]\nartist_name = sys.argv[3]\n\nspotify(id, artist_name)\ntwitter(id, artist_name)\ninstagram(id, artist_name)\nyoutube(id, artist_name)\ndeezer(id, artist_name)\npandora(id, artist_name)\nsoundcloud(id, artist_name)\ntiktok(id, artist_name)\nprint("finished with " + artist_name)\n'}, {'name': 'deezer.py', 'language': 'Python', 'contents': 'import requests\nimport sys\nimport csv\n\napi_token = sys.argv[1] \nid = sys.argv[2] \nartist_name = sys.argv[3]\nsource = "deezer"\nfilename = source+\'.csv\'\n\nurl = "https://api.chartmetric.com/api/artist/%s/stat/%s/"%(id, source)\n\nheaders = {\n        \'Authorization\' : \'Bearer %s\'%api_token\n        }\n\nresponse = requests.get(url, params = {\'since\':\'2017-01-01\', \'interpolated\':\'true\'}, headers=headers)\n\nif response:\n    f = open(r"../../../dev/projects/ATLSE/artist_data/artists/%s/%s"%(artist_name, filename), "a")\n    #f = open(filename, "a")\n    split_response = response.text.split(",")\n    for row in split_response:\n        f.write(row + ",\\n")    \n    f.close()    \nelse: \n    print(\'[{}] Error occurred with artist: {} (id: {})\'.format(source, artist_name, id))\n'}, {'name': 'instagram.py', 'language': 'Python', 'contents': 'import requests\nimport sys\nimport csv\n\napi_token = sys.argv[1] \nid = sys.argv[2] \nartist_name = sys.argv[3]\nsource = "instagram"\nfilename = source+\'.csv\'\n\nurl = "https://api.chartmetric.com/api/artist/%s/stat/%s/"%(id, source)\n\nheaders = {\n        \'Authorization\' : \'Bearer %s\'%api_token\n        }\n\nresponse = requests.get(url, params = {\'since\':\'2017-01-01\', \'interpolated\':\'true\'}, headers=headers)\n\nif response:\n    f = open(r"../../../dev/projects/ATLSE/artist_data/artists/%s/%s"%(artist_name, filename), "a")\n    #f = open(filename, "a")\n    split_response = response.text.split(",")\n    for row in split_response:\n        f.write(row + ",\\n")    \n    f.close()    \nelse: \n    print(\'[{}] Error occurred with artist: {} (id: {})\'.format(source, artist_name, id))\n\n'}, {'name': 'soundcloud.py', 'language': 'Python', 'contents': 'import requests\nimport sys\nimport csv\n\napi_token = sys.argv[1] \nid = sys.argv[2] \nartist_name = sys.argv[3]\nsource = "soundcloud"\nfilename = source+\'.csv\'\n\nurl = "https://api.chartmetric.com/api/artist/%s/stat/%s/"%(id, source)\n\nheaders = {\n        \'Authorization\' : \'Bearer %s\'%api_token\n        }\n\nresponse = requests.get(url, params = {\'since\':\'2017-01-01\', \'interpolated\':\'true\'}, headers=headers)\n\nif response:\n    f = open(r"../../../dev/projects/ATLSE/artist_data/artists/%s/%s"%(artist_name, filename), "a")\n    #f = open(filename, "a")\n    split_response = response.text.split(",")\n    for row in split_response:\n        f.write(row + ",\\n")    \n    f.close()    \nelse: \n    print(\'[{}] Error occurred with artist: {} (id: {})\'.format(source, artist_name, id))\n'}, {'name': 'spotify.py', 'language': 'Python', 'contents': 'import requests\nimport sys\nimport csv\n\napi_token = sys.argv[1] \nid = sys.argv[2] \nartist_name = sys.argv[3]\nsource = "spotify"\nfilename = source+\'.csv\'\n\nurl = "https://api.chartmetric.com/api/artist/%s/stat/%s/"%(id, source)\n\nheaders = {\n        \'Authorization\' : \'Bearer %s\'%api_token\n        }\n\nresponse = requests.get(url, params = {\'since\':\'2017-01-01\', \'interpolated\':\'true\'}, headers=headers)\n\nif response:\n    f = open(r"../../../dev/projects/ATLSE/artist_data/artists/%s/%s"%(artist_name, filename), "a")\n    #f = open(filename, "a")\n    split_response = response.text.split(",")\n    for row in split_response:\n        f.write(row + ",\\n")    \n    f.close()\nelse: \n    print(\'[{}] Error occurred with artist: {} (id: {})\'.format(source, artist_name, id))\n'}, {'name': 'tiktok.py', 'language': 'Python', 'contents': 'import requests\nimport sys\nimport csv\n\napi_token = sys.argv[1] \nid = sys.argv[2] \nartist_name = sys.argv[3]\nsource = "tiktok"\nfilename = source+\'.csv\'\n\nurl = "https://api.chartmetric.com/api/artist/%s/stat/%s/"%(id, source)\n\nheaders = {\n        \'Authorization\' : \'Bearer %s\'%api_token\n        }\n\nresponse = requests.get(url, params = {\'since\':\'2017-01-01\', \'interpolated\':\'true\'}, headers=headers)\n\nif response:\n    f = open(r"../../../dev/projects/ATLSE/artist_data/artists/%s/%s"%(artist_name, filename), "a")\n    #f = open(filename, "a")\n    split_response = response.text.split(",")\n    for row in split_response:\n        f.write(row + ",\\n")    \n    f.close()    \nelse: \n    print(\'[{}] Error occurred with artist: {} (id: {})\'.format(source, artist_name, id))\n'}, {'name': 'twitter.py', 'language': 'Python', 'contents': 'import requests\nimport sys\nimport csv\n\napi_token = sys.argv[1] \nid = sys.argv[2] \nartist_name = sys.argv[3]\nsource = "twitter"\nfilename = source+\'.csv\'\n\nurl = "https://api.chartmetric.com/api/artist/%s/stat/%s/"%(id, source)\n\nheaders = {\n        \'Authorization\' : \'Bearer %s\'%api_token\n        }\n\nresponse = requests.get(url, params = {\'since\':\'2017-01-01\', \'interpolated\':\'true\'}, headers=headers)\n\nif response:\n    f = open(r"../../../dev/projects/ATLSE/artist_data/artists/%s/%s"%(artist_name, filename), "a")\n    #f = open(filename, "a")\n    split_response = response.text.split(",")\n    for row in split_response:\n        f.write(row + ",\\n")    \n    f.close()    \nelse: \n    print(\'[{}] Error occurred with artist: {} (id: {})\'.format(source, artist_name, id))\n'}, {'name': 'youtube_artist.py', 'language': 'Python', 'contents': 'import requests\nimport sys\nimport csv\n\napi_token = sys.argv[1] \nid = sys.argv[2] \nartist_name = sys.argv[3]\nsource = "youtube_artist"\nfilename = source+\'.csv\'\n\nurl = "https://api.chartmetric.com/api/artist/%s/stat/%s/"%(id, source)\n\nheaders = {\n        \'Authorization\' : \'Bearer %s\'%api_token\n        }\n\nresponse = requests.get(url, params = {\'since\':\'2017-01-01\', \'interpolated\':\'true\'}, headers=headers)\n\nif response:\n    f = open(r"../../../dev/projects/ATLSE/artist_data/artists/%s/%s"%(artist_name, filename), "a")\n    #f = open(filename, "a")\n    split_response = response.text.split(",")\n    for row in split_response:\n        f.write(row + ",\\n")    \n    f.close()    \nelse: \n    print(\'[{}] Error occurred with artist: {} (id: {})\'.format(source, artist_name, id))\n'}, {'name': 'youtube_channel.py', 'language': 'Python', 'contents': 'import requests\nimport sys\nimport csv\n\napi_token = sys.argv[1] \nid = sys.argv[2] \nartist_name = sys.argv[3]\nsource = "youtube_channel"\nfilename = source+\'.csv\'\n\nurl = "https://api.chartmetric.com/api/artist/%s/stat/%s/"%(id, source)\n\nheaders = {\n        \'Authorization\' : \'Bearer %s\'%api_token\n        }\n\nresponse = requests.get(url, params = {\'since\':\'2017-01-01\', \'interpolated\':\'true\'}, headers=headers)\n\nif response:\n    f = open(r"../../../dev/projects/ATLSE/artist_data/artists/%s/%s"%(artist_name, filename), "a")\n    #f = open(filename, "a")\n    split_response = response.text.split(",")\n    for row in split_response:\n        f.write(row + ",\\n")    \n    f.close()    \nelse: \n    print(\'[{}] Error occurred with artist: {} (id: {})\'.format(source, artist_name, id))\n'}], 'primaryLanguage': 'Rust', 'stars': 0, 'readme': '# ATL Sound Exchange -- Proof of Concept #\n\n### What if you could invest in a product that you know better than anyone? ###\n---------------------\n\nThe idea is to build an **crowd-funded record label that functions as Stock Market**. Instead of businesses, the stock market would market musical artists by charting streaming data and calculating a _share price (i.e. partial ownership in a record deal)_ and _dividends (i.e. royalties)_. Thus allowing day-one fans to act as **A&R**\'s and put their money where their mouth is. \n\n**A musical artist is a business**. They require startup capital and distribution, they benefit from network economies, counter-positioning, and branding. There is also a strong opportunity for a derivatives market.\n\nFor the proof of concept we will create a simulation of this market by scraping an artists streaming data and allowing users to perform paper trading (trading with fake money). \n\n* Why would it be appealing?\n    - For investors: \n        + Invest in lucrative businesses that issue regular dividends that they truly know and have a feel for, rather than trying to speculate on markets which they are unfamiliar with.\n        + Return on investment for the day 1 fans \n    - For artists: \n        + Transparent contracts, much more control over terms \n        + Clear route to buying back their masters \n        + Deal with people that love them rather than cold, calculating label execs\n        + Highly distributed distribution network\n    - Strong network effects\n    - First mover advantage\n    - Brand recognition\n    - Take power away from predatory and exploitative record industry, give it to the fans\n\n* Musical artists are being screwed and extorted by record labels and their shady business practices \n    - https://www.youtube.com/watch?v=6fa8lJKTy0I\n    - Record labels are companies that produce, distribute, and promote music and other audio recordings. While record labels can play a valuable role in helping artists to create and distribute their music, some artists have criticized the industry for exploitative practices that take advantage of musicians with unfair record deals.\n\n    One common complaint is that record labels often offer musicians contracts with terms that are heavily weighted in favor of the label. These contracts can include provisions that allow the label to take a large percentage of an artist\'s earnings from record sales and other sources of income, such as touring and merchandise sales. Some contracts may also include terms that grant the label ownership of an artist\'s work, including the right to control the use and distribution of their music.\n\n    Artists have also raised concerns about the lack of transparency and accountability within the record label industry, with some alleging that they have been denied access to financial records and have not received fair payment for their work. Some artists have also reported being subject to pressure from record labels to conform to certain image and branding requirements, or to produce music that is more commercial and less artistically authentic.\n\n    Overall, while record labels can play a valuable role in helping artists to create and distribute their music, it is important for musicians to be aware of the potential for exploitation and to carefully review and negotiate the terms of any record deal to ensure that it is fair and equitable.\n\n![ATLSE](https://user-images.githubusercontent.com/79671850/197922859-5f2301e6-b8b7-4a47-bead-f97543d069ca.png)\n<blockquote>     "The problem of collective action is a variant of the prisoners\' dilemma, albeit one with many more than two prisoners... How can unpopular tyrants control large populations for long periods [when] a simultaneous move by the masses stands a very good chance of success.\nBut the communication and coordination required for such action is difficult, and the oppresors, knowing the power of the masses, take special steps to keep it difficult. When the people must act individually and hope that the momentum will build up, the question arises, \'Who is going to be the first?\'" </blockquote>\n- "The art of strategy"\n\n\n\n'}, {'name': 'crafting_interpreters', 'files': [{'name': 'main.rs', 'language': 'Rust', 'contents': 'fn main() {\n    // PROCESS VM: TO DO\n    println!("Temporary Placeholder");\n}\n'}, {'name': 'main.rs', 'language': 'Rust', 'contents': 'use clap::{App, Arg};\n\nmod scanner;\n\n// Scanner takes in raw source code as a series of characters and groups it into a series\n// of chunks called tokens ("words", and "punctuation" that make up the language\'s grammar)\n\nfn main() {\n    let matches = App::new("treewalker")\n        .version("0.1.0")\n        .author("Nicholi Caron <nmcaron@protonmail.ch>")\n        .about("A treewalk interpreter for the Lox language written in Rust")\n        .arg(\n            Arg::new("filename")\n                .short(\'f\')\n                .takes_value(true)\n                .value_name("FILENAME")\n                .help("Name of file to be compiled")\n                .required(false)\n                .max_values(1),\n        )\n        .get_matches();\n\n    if let Some(f) = matches.get_one::<String>("filename") {\n        // Impl error handling here if file is unavailable\n        let _scan = scanner::run_file(f.clone());\n    } else {\n        let _scan = scanner::run_prompt();\n    }\n}\n'}, {'name': 'scanner.rs', 'language': 'Rust', 'contents': '// Scanner takes in raw source code as a series of characters and groups it into a series\n// of chunks called tokens ("words", and "punctuation" that make up the language\'s grammar)\n\nuse std::fs;\nuse std::io::*;\n// When do we return io::Error??\n// REPL\npub fn run_file(path: String) -> Result<()> {\n    if let Ok(file) = fs::read_to_string(path) {\n        scan(file);\n    } else {\n        let file_io_error = Error::from(ErrorKind::NotFound);\n        return Err(file_io_error);\n    }\n    Ok(())\n    // read file as bytes??\n}\n\npub fn run_prompt() -> Result<()> {\n    println!("Please enter the file to be compiled: ");\n\n    match stdin().lines().next().unwrap() {\n        Ok(path) => {\n            run_file(path).unwrap();\n            Ok(())\n        }\n        Err(name_parsing_error) => Err(name_parsing_error),\n    }\n}\n\n// TO DO:\n// Do we tokenize or discard spaces/newlines?\n// Associate line numbers and column numbers with tokens\nfn scan(source: String) -> Vec<Token> {\n    let mut tokens: Vec<Token> = Vec::new();\n    let mut char_indices = source.char_indices().peekable();\n\n    // let\'s use CharIndices to keep track of state when we need to check if a token is single or multi-character\n    // CharIndices provides peekable method to let us conditionally advance the current index if we have a multi-character token\n    // Using while let here instead of for in to avoid moving the iterator produced by char_indices\n    while let Some((index, character)) = char_indices.next() {\n        let token = match character {\n            // match a single token\n            \'+\' => Token::Plus,\n            \'=\' => match char_indices.next_if_eq(&(index + 1, \'=\')) {\n                Some(_) => Token::EqualEqual,\n                None => Token::Equal,\n            },\n            \'!\' => match char_indices.next_if_eq(&(index + 1, \'=\')) {\n                Some(_) => Token::NotEqual,\n                None => Token::Invalid("!".to_string()),\n            },\n            // Checking for strings\n\n            // take_while method conditionally consumes and returns elements of an iterator as long as its predicate function evaluates to true\n            // when the predicate function evals to false, the iterator terminates\n            // take_while takes possession of the original iterator, so we will instead borrow it mutable via by_ref()\n            // elements consumed by take_while are also removed from original iterator so we don\'t have to worry about double counting\n            \'"\' => {\n                let mut last_char_matched: char = \'\\0\';\n\n                let s: String = char_indices\n                    .by_ref()\n                    .take_while(|(_index, character)| {\n                        last_char_matched = *character;\n                        *character != \'"\'\n                    })\n                    // call to map ditches the index value, keeping the character so we can append it to s\n                    .map(|(_index, character)| character)\n                    .collect();\n\n                match last_char_matched {\n                    \'"\' => Token::StringLiteral(s),\n                    _ => Token::Invalid("Unterminated literal".to_string()),\n                }\n            }\n            n if char::is_numeric(n) => {\n                let s: String = char_indices\n                    .by_ref()\n                    .take_while(|(_index, character)| char::is_numeric(*character))\n                    .map(|(_index, character)| character)\n                    .collect();\n\n                let number: u32 = s.parse::<u32>().unwrap();\n                Token::Number(number)\n            }\n            _ => Token::Invalid(format!("{}", character)),\n        };\n        tokens.push(token);\n    }\n    tokens\n}\n\nenum Token {\n    Plus,\n    Equal,\n    EqualEqual,\n    NotEqual,\n    Number(u32),\n    StringLiteral(String),\n    Invalid(String),\n}\n'}], 'primaryLanguage': 'Rust', 'stars': 0, 'readme': '# crafting_interpreters\nMy Rust port of the interpreters for the Lox language covered in Robert Nystrom\'s "Crafting Interpreters" book.\n\n[Lox](https://craftinginterpreters.com/the-lox-language.html) is a simple, dynamically {typed,dispatched}, high level scripting language with C-like syntax, Scheme-like scoping, and garbage collection. \n'}, {'name': 'CMU_compilers', 'files': [{'name': 'main.rs', 'language': 'Rust', 'contents': 'mod scanner;\n\nuse clap::{arg, Command};\n\nfn main() {\n    let matches = Command::new("C0mpiler")\n        .version("0.1.0")\n        .author("Nicholi Caron <nmcaron@protonmail.ch>")\n        .about("A compiler for the C0 programming language")\n        .arg(arg!(-f --file <FILE> "Name of the file to be compiled"))\n        .get_matches();\n\n    /* let matches = command!()\n        .arg(Arg::new("filename"))\n        .short_flag(\'f\')\n        .long("filename")\n        .get_matches();\n    .arg(\n        Arg::new("filename")\n            .short(\'f\')\n            .takes_value(true)\n            .value_name("FILENAME")\n            .help("Name of file to be compiled")\n            .required(false)\n            .max_values(1),\n    )\n    .get_matches();\n    */\n\n    if let Some(f) = matches.get_one::<String>("filename") {\n        // Impl error handling here if file is unavailable\n        let _scan = scanner::run_file(f.clone());\n    } else {\n        let _scan = scanner::run_prompt();\n    }\n}\n'}, {'name': 'parser.rs', 'language': None, 'contents': ''}], 'primaryLanguage': 'Rust', 'stars': 3, 'readme': "# Transition Diagrams for C0's Finite Automata #\n\n### Identifiers ### \n![id_transition_diagram](https://user-images.githubusercontent.com/79671850/205413010-df4bd206-a895-49c1-a560-17f361edb022.png)\n-------------\n### Numbers ###\n![num_transition_diagram](https://user-images.githubusercontent.com/79671850/205413122-a1d9fe09-cb33-4e90-8cfb-6156ed0fc017.png)\n-------------\n### Decimal Numbers ### \n![decnum_transition_diagram](https://user-images.githubusercontent.com/79671850/205419455-a299e953-dce4-4850-835d-17f02705d3ac.png)\n-------------\n\n### Hexadecimal Numbers ###\n![hexnum_transition_diagram](https://user-images.githubusercontent.com/79671850/205413268-b8599d8c-38fc-4b52-af3d-9e91f5b1203d.png)\n-------------\n\n### String Literals ###\n![strlit_transition_diagram](https://user-images.githubusercontent.com/79671850/205413275-2d41a772-3099-4852-9e87-ff00f282c84a.png)\n-------------\n\n### Character Literals ###\n![chrlit_transition_diagram](https://user-images.githubusercontent.com/79671850/205413280-ca564051-c7cf-4d35-8337-13e60a3a9860.png)\n-------------\n\n### Library Literals ###\n![liblit_transition_diagram](https://user-images.githubusercontent.com/79671850/205413288-9d259d74-e8c9-4b4d-a228-1e09b854a963.png)\n-------------\n\n### SChar ###\n![schar_transition_diagram](https://user-images.githubusercontent.com/79671850/205413320-806b650b-0fe0-4aca-9217-b9a569bf56f3.png)\n-------------\n\n### CChar ###\n![cchar_transition_diagram](https://user-images.githubusercontent.com/79671850/205413327-8c46bb61-b2f4-4f13-8709-c9a4f3f90cf8.png)\n-------------\n\n\n### NChar ###\n![nchar_transition_diagram](https://user-images.githubusercontent.com/79671850/205413349-57a9751e-b35d-4b63-bfb9-e4a90db38b5f.png)\n-------------\n\n### LChar ###\n![lchar_transition_diagram](https://user-images.githubusercontent.com/79671850/205413355-d0c0faf3-e724-46ee-9944-705f037b523c.png)\n-------------\n\n### Escape Sequences ###\n![esc_transition_diagram](https://user-images.githubusercontent.com/79671850/205413359-281afd9b-ca55-4bee-b1f7-2922c5afd94a.png)\n-------------\n\n### Separators ###\n![sep_transition_diagram](https://user-images.githubusercontent.com/79671850/205413367-eefb166f-42c8-4c1f-a8a5-64284b0d64a7.png)\n-------------\n\n### Unary Operators ###\n![unop_transition_diagram](https://user-images.githubusercontent.com/79671850/205413373-93649083-c3f5-449e-846c-b1ef576514e0.png)\n-------------\n\n### Binary Operators ###\n![binop_transition_diagram](https://user-images.githubusercontent.com/79671850/224458998-7dca36e4-d9a5-4525-ae44-9b34dbe5a80c.png)\n\n-------------\n\n### Assignment Operators ###\n![asnop_transition_diagram](https://user-images.githubusercontent.com/79671850/205413385-3ed63513-f791-40b1-9b34-8d15931599de.png)\n-------------\n\n### Postfix Operators ###\n![postop_transition_diagram](https://user-images.githubusercontent.com/79671850/205419399-89a71620-730e-4b7c-a5be-0bf71f682dad.png)\n\n"}, {'name': 'project_euler', 'files': [{'name': 'main.rs', 'language': 'Rust', 'contents': '// Title: Multiples of 3 or 5\n// --------------------------\n// If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. \n// The sum of these multiples is 23.\n//\n// Find the sum of all the multiples of 3 or 5 below 1000.\n//\n\nfn main() {\n    let limit: u32 = 1000;\n    let result: u32 = (0..limit).filter(|&x| x%3 == 0 || x%5 == 0).sum();\n    println!("Sum of all multiples of 3 or 5 below 1000 is: {}", result);\n}\n'}, {'name': 'main.rs', 'language': 'Rust', 'contents': 'fn main() {\n    println!("Hello, world!");\n}\n'}, {'name': 'main.rs', 'language': 'Rust', 'contents': 'fn main() {\n    println!("Hello, world!");\n}\n'}, {'name': 'main.rs', 'language': 'Rust', 'contents': 'fn main() {\n    println!("Hello, world!");\n}\n'}, {'name': 'main.rs', 'language': 'Rust', 'contents': 'fn main() {\n    println!("Hello, world!");\n}\n'}, {'name': 'main.rs', 'language': 'Rust', 'contents': 'fn main() {\n    println!("Hello, world!");\n}\n'}, {'name': 'main.rs', 'language': 'Rust', 'contents': 'fn main() {\n    println!("Hello, world!");\n}\n'}, {'name': 'main.rs', 'language': 'Rust', 'contents': 'fn main() {\n    println!("Hello, world!");\n}\n'}, {'name': 'main.rs', 'language': 'Rust', 'contents': 'fn main() {\n    println!("Hello, world!");\n}\n'}, {'name': 'main.rs', 'language': 'Rust', 'contents': 'fn main() {\n    println!("Hello, world!");\n}\n'}, {'name': 'main.rs', 'language': 'Rust', 'contents': 'fn main() {\n    println!("Hello, world!");\n}\n'}, {'name': 'main.rs', 'language': 'Rust', 'contents': 'fn main() {\n    println!("Hello, world!");\n}\n'}, {'name': 'main.rs', 'language': 'Rust', 'contents': '// Title: Even Fibonacci Numbers\n// ------------------------------\n// Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:\n// 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...\n// By considering the terms in the Fibonacci sequence whose value do not exceed four million, find\n// the sum of the even-valued terms.\n\nfn main() {\n    // try to use fold iterator adapter\n}\n'}, {'name': 'main.rs', 'language': 'Rust', 'contents': 'fn main() {\n    println!("Hello, world!");\n}\n'}, {'name': 'main.rs', 'language': 'Rust', 'contents': 'fn main() {\n    println!("Hello, world!");\n}\n'}, {'name': 'main.rs', 'language': 'Rust', 'contents': 'fn main() {\n    println!("Hello, world!");\n}\n'}, {'name': 'main.rs', 'language': 'Rust', 'contents': 'fn main() {\n    println!("Hello, world!");\n}\n'}, {'name': 'main.rs', 'language': 'Rust', 'contents': 'fn main() {\n    println!("Hello, world!");\n}\n'}, {'name': 'main.rs', 'language': 'Rust', 'contents': 'fn main() {\n    println!("Hello, world!");\n}\n'}, {'name': 'main.rs', 'language': 'Rust', 'contents': 'fn main() {\n    println!("Hello, world!");\n}\n'}, {'name': 'main.rs', 'language': 'Rust', 'contents': 'fn main() {\n    println!("Hello, world!");\n}\n'}, {'name': 'main.rs', 'language': 'Rust', 'contents': 'fn main() {\n    println!("Hello, world!");\n}\n'}, {'name': 'main.rs', 'language': 'Rust', 'contents': 'fn main() {\n    println!("Hello, world!");\n}\n'}, {'name': 'main.rs', 'language': 'Rust', 'contents': 'fn main() {\n    println!("Hello, world!");\n}\n'}, {'name': 'main.rs', 'language': 'Rust', 'contents': 'fn main() {\n    println!("Hello, world!");\n}\n'}, {'name': 'main.rs', 'language': 'Rust', 'contents': 'fn main() {\n    println!("Hello, world!");\n}\n'}, {'name': 'main.rs', 'language': 'Rust', 'contents': 'fn main() {\n    println!("Hello, world!");\n}\n'}, {'name': 'main.rs', 'language': 'Rust', 'contents': 'fn main() {\n    println!("Hello, world!");\n}\n'}, {'name': 'main.rs', 'language': 'Rust', 'contents': 'fn main() {\n    println!("Hello, world!");\n}\n'}, {'name': 'main.rs', 'language': 'Rust', 'contents': 'fn main() {\n    println!("Hello, world!");\n}\n'}, {'name': 'main.rs', 'language': 'Rust', 'contents': 'fn main() {\n    println!("Hello, world!");\n}\n'}, {'name': 'main.rs', 'language': 'Rust', 'contents': 'fn main() {\n    println!("Hello, world!");\n}\n'}, {'name': 'main.rs', 'language': 'Rust', 'contents': 'fn main() {\n    println!("Hello, world!");\n}\n'}, {'name': 'main.rs', 'language': 'Rust', 'contents': 'fn main() {\n    println!("Hello, world!");\n}\n'}], 'primaryLanguage': 'Rust', 'stars': 0, 'readme': '# project_euler\nThese are my solutions to some of the problems from Project Euler using the Rust programming language.\n\n                    .-.\n                   ( (\n                    `-\'\n\n\n\n \n                     .   - To the Moon!\n                    .\'.\n                    |o|\n                   .\'o\'.\n                   |.-.|\n                   \'   \'\n                    ( )\n                     )\n                    ( )\n\n \n                ____\n           .-\'""p 8o""`_\n       .-\'8888P\'Y.`Y[ \' `-.\n      ,\'88888b.J8oo_      \'`.\n    ,\' ,88888888888["        Y`.\n   /   8888888888P            Y8\\\n  /    Y8888888P\'             ]88\\\n :     `Y88\'   P              `888:\n :       Y8.oP \'- >            Y88:\n |          `Yb  __             `\'|\n :            `\'d8888bo.          :\n :             d88888888ooo.      ;\n  \\            Y88888888888P     /\n   \\            `Y88888888P     /\n    `.            d88888P\'    ,\'\n      `.          888PP\'    ,\'\n        `-.      d8P\'    ,-\' \n           `-.,,_\'__,,.-\'\'\n\n'}, {'name': 'CSE1321L', 'files': [{'name': 'assignment1A.cpp', 'language': 'C++', 'contents': '/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring \'23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nAssignment#: 1A  \n*/\n\n#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nint main(int argc, char ** argv) {\n\tint r, g, b;\n\tint inverted_r, inverted_g, inverted_b;\n\tfloat inverted_r_float, inverted_g_float, inverted_b_float;\n\n\tcout << "Enter a red value (0-255): ";\n\tcin >> r;\n\tcout << "Enter a green value (0-255): ";\n\tcin >> g;\n\tcout << "Enter a blue value (0-255): ";\n\tcin >> b;\n\t\n\tinverted_r = 255 - r;\n\tinverted_g = 255 - g;\n\tinverted_b = 255 - b;\n\n\tcout << "The inverted color is red=" << inverted_r << ", green=" << \n\t\tinverted_g << ", blue=" << inverted_b << \'\\n\';\n\t\n\tinverted_r_float = static_cast<float>(inverted_r) / 255;\n\tinverted_g_float = static_cast<float>(inverted_g) / 255;\n\tinverted_b_float = static_cast<float>(inverted_b) / 255;\n\n\tcout << setprecision(4);\n\tcout << "With floating points, that would be red=" << inverted_r_float\n\t\t<< ", green=" << inverted_g_float << ", blue=" << inverted_b_float\n\t\t<< \'\\n\';\n\treturn 0;\n}\n'}, {'name': 'assignment1B.cpp', 'language': 'C++', 'contents': '/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring \'23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nAssignment#: 1B  \n*/\n\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint main(int argc, char ** argv) {\n\tstring item1, item2;\n\tint quantity1, quantity2;\n\tfloat price1, price2, intermediate_price1, intermediate_price2;\n\t\n\tcout << "What\'re you buying? ";\n\tgetline(cin, item1, \'\\n\');\n\tcout << "How many? ";\n\tcin >> quantity1;\n\tcout << "What do they cost? ";\n\tcin >> price1;\n\n\tintermediate_price1 = price1 * quantity1;\n\n\tcout << "\\nWhat else\'re you buying? ";\n\tcin.ignore();\n\tgetline(cin, item2, \'\\n\');\n\tcout << "How many? ";\n\tcin >> quantity2;\n\tcout << "What do they cost? ";\n\tcin >> price2;\n\n\tintermediate_price2 = price2 * quantity2;\n\n\tfloat total_cost = intermediate_price1 + intermediate_price2;\n\n\tcout << "\\nYour list: \\n----\\n" << item1 << " (" << quantity1 << ")\\n" << \n\t\t\'$\' << price1 << " ($" << intermediate_price1 << " total)" << endl;\n\tcout << item2 << " (" << quantity2 << ")\\n" << \'$\' << price2 << " ($" << \n\t\tprice2 * quantity2 << " total)" << endl <<"Total Cost: $" << \n\t\ttotal_cost << "\\n----\\n";\n\n\treturn 0;\n}\n'}, {'name': 'assignment1C.cpp', 'language': 'C++', 'contents': '/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring \'23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nAssignment#: 1C \n*/\n\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint main(int argc, char ** argv) {\n\tint day, month_num, year;\n\tstring month_str;\n\n\tcout << "Enter the day (number): ";\n\tcin >> day;\n\tcout << "Enter the month (number): ";\n\tcin >> month_num;\n\tcout << "Enter the month (String): ";\n\tcin >> month_str;\n\tcout << "Enter the year (number): ";\n\tcin >> year;\n\n\tcout << "Here are some ways to represent the date: \\n";\n\tcout << month_num << \'/\' << day << \'/\' << year << \'\\n\';\n\tcout << year << \'/\' << day << \'/\' << month_num << \'\\n\';\n\tcout << day << \'/\' << month_num << \'/\' << year << \'\\n\';\n\tcout << month_str << \' \' << day << ", " << year << \'\\n\';\n\tcout << day << \' \' << month_str << \' \' << year << \'\\n\';\n\treturn 0;\n}\n'}, {'name': 'assignment2A.cpp', 'language': 'C++', 'contents': "/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring '23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nAssignment#:  \n*/\n\nint main(int argc, char ** argv) {\n\t\n\treturn 0;\n}\n"}, {'name': 'assignment2B.cpp', 'language': 'C++', 'contents': "/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring '23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nAssignment#:  \n*/\n\nint main(int argc, char ** argv) {\n\t\n\treturn 0;\n}\n"}, {'name': 'assignment2C.cpp', 'language': 'C++', 'contents': "/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring '23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nAssignment#:  \n*/\n\nint main(int argc, char ** argv) {\n\t\n\treturn 0;\n}\n"}, {'name': 'assignment3A.cpp', 'language': 'C++', 'contents': '/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring \'23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nAssignment#: 3A \n*/\n// Cretaceous Park Map\n\n#include <iostream>\nusing namespace std;\n\nint main(int argc, char ** argv) {\n\tfloat x, y;\n\tcout << "[Cretaceous Park GIS]\\n";\n\tcout << "X Coordinate: ";\n\tcin >> x;\n\n\tcout << "Y Coordinate: ";\n\tcin >> y;\n\n\t// We will slice vertically parallel to the y-axis and evaluate the y\n\t// value to determine the area\n\n\t// Boundary ownership is a bit ambiguous, so we will give ownership to\n\t// an areas lower bounds to remain consistent with provided test case\n\t// e.g. (2,2) belongs to T.Rex Lake\n\t\n\t//First case is out of bounds case\n\tif (x > 8.0f || x < 0.0f || y > 8.0f || y < 0.0f) {\n\t\tcout << "You have left the boundaries of the park.\\n"\n\t\t\t<< "Please return immediately.";\n\t} else if (x < 2.0f) {\n\t\tcout << "You are in the Triceratops Grasslands\\n";\n\t} else if (x >= 2.0f && x < 4.0f) {\n\t\tif (y >= 2.0f && y < 6.0f) {\n\t\t\tcout << "You are in T.Rex Lake\\n";\n\t\t} else {\n\t\t\tcout << "You are in the Triceratops Grasslands\\n";\n\t\t}\n\t} else if (x >= 4.0f && x < 5.0f) {\n\t\tcout << "You are in the Triceratops Grasslands\\n";\n\t} else if (x >= 5.0f && x < 6.0f) {\n\t\tif (y < 2.0f) {\n\t\t\tcout << "You are in the Pterodactyl Aviary\\n";\n\t\t} else if (y >= 2.0f && y < 5.0f) {\n\t\t\tcout << "You are in the Triceratops grassland\\n";\n\t\t} else if (y >= 5.0f) {\n\t\t\tcout << "You are in the Deinonychus Pen.\\n";\n\t\t}\n\t} else {\n\t\tif (y < 2.0f) {\n\t\t\tcout << "You are in the Pterodactyl Aviary\\n";\n\t\t} else if (y >= 2.0f && y < 4.0f) {\n\t\t\tcout << "You are in the Visitor\'s Center\\n";\n\t\t} else if (y >= 4.0f && y < 5.0f) {\n\t\t\tcout << "You are in the Triceratops Grasslands\\n";\n\t\t} else {\n\t\t\tcout << "You are in the Deinonychus Pen.\\n";\n\t\t}\n\t}\n\n\treturn 0;\n}\n'}, {'name': 'assignment3B.cpp', 'language': 'C++', 'contents': '/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring \'23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nAssignment#: 3B \n*/\n\n// Image Color Depth\n\n#include <iostream>\nusing namespace std;\n\nint main(int argc, char ** argv) {\n\tint width, height, size;\n\tcout << "[Image Encoding Checker]\\n";\n\n\tcout << "What is the image width? ";\n\tcin >> width;\n\t\n\tcout << "What is the image height? ";\n\tcin >> height;\n\n\tcout << "What is the file size (in bytes)? ";\n\tcin >> size;\n\n\t// Width and height should be positive\n\t// Size should be some multiple of (height*width)\n\tif (width <=0 || height <= 0 || size % (width*height) != 0) {\n\t\tcout << "The information is invalid - please re-enter it.\\n";\n\t\treturn 0;\n\t// Size = 3C * (height*width) \n\t// BPC = 8*C\n\t} else switch (size / (3*height*width)) {\n\t\tcase 1: \n\t\t\tcout << "The RGB image is encoded with 8 bits per channel.\\n";\n\t\t\tbreak;\n\t\tcase 2: \n\t\t\tcout << "The RGB image is encoded with 16 bits per channel.\\n";\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tcout << "The RGB image is encoded with 24 bits per channel.\\n";\n\t\t\tbreak;\n\t\tdefault: \n\t\t\tcout << "Unable to read this encoding [outside of range].\\n";\n\t\t\tbreak;\n\t}\n\treturn 0;\n}\n'}, {'name': 'assignment3C.cpp', 'language': 'C++', 'contents': '/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring \'23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nAssignment#: 3C  \n*/\n\n// Decision Trees\n#include <iostream>\n#include <cstdlib>\n#include <string>\nusing namespace std;\n\nint main(int argc, char ** argv) {\n\tstring userInput;\n\n\tcout << "[Cretaceous Park Dialog]\\n";\n\tcout << "Oh no, the power has gone out at Cretaceous Park! \\n";\n\tcout << "1) What does that mean?\\n";\n\t// The first provided test case does not match this input, but problem \n\t// states that we do not have to worry about invalid input\n\tcout << "2) No, I just turned the light off." << endl;\n\tgetline (cin, userInput);\n\tif (userInput.compare("No, I just turned the light off.") == 0) {\n\t\tcout << "\\nOh thank goodness!\\n";\n\t\treturn 0;\n\t// Again, problem states we don\'t have to worry about invalid input,\n\t// so we don\'t have to explicitly compare userInput against case 2\n\t} else {\n\t\tcout << "\\nThe dinosaurs will get loose... again...\\n";\n\t\tcout << "1) Life finds a way...\\n";\n\t\tcout << "2) What do we do?\\n";\n\t\tgetline (cin, userInput);\n\t\tif (userInput.compare("Life finds a way...") == 0) {\n\t\t\tcout << "\\nThat\'s not helpful right now!\\n";\n\t\t\tcout << "We have to evacuate the park!\\n";\n\t\t} else {\n\t\t\t// I only wrote this print statement twice for formatting\n\t\t\t// reasons, even though it is printed in either branch\n\t\t\tcout << "\\nWe have to evacuate the park!\\n";\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n'}, {'name': 'Assignment4A.cpp', 'language': 'C++', 'contents': '/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring \'23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nAssignment#: 4A \n*/\n\n#include<iostream>\nusing namespace std;\n\nint main(int argc, char ** argv) {\n\tcout << "What loop do you want to use?\\n";\n\tcout << "1) A loop that might run zero or more times\\n";\n\tcout << "2) A loop that will always run at least once\\n";\n\tcout << "3) A loop with a predetermined start and end\\n";\n\n\tint selection, start, end = 0;\n\tcin >> selection;\n\t\n\tswitch (selection) {\n\t\tcase 1: \n\t\t\tcout << "What\'s your start number? ";\n\t\t\tcin >> start;\n\t\t\twhile (start >= end) {\n\t\t\t\tcout << start << ", ";\n\t\t\t\tstart--;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tcout << "What\'s your start number? ";\n\t\t\tcin >> start;\n\t\t\tdo {\n\t\t\t\tcout << start << ", ";\n\t\t\t\tstart--;\n\t\t\t} \n\t\t\twhile (start >= end);\n\t\t\tbreak;\n\t\tcase 3: \n\t\t\tcout << "What\'s your start number? ";\n\t\t\tcin >> start;\n\t\t\tcout << "What\'s your end number? ";\n\t\t\tcin >> end;\n\t\t\tcout << "Counting: ";\n\t\t\tfor (int index = start; index >= end; index--) {\n\t\t\t\tcout << index << ", ";\n\t\t\t}\n\t\t\tbreak;\n\t}\n\t\n\treturn 0;\n}\n'}, {'name': 'Assignment4B.cpp', 'language': 'C++', 'contents': '/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring \'23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nAssignment#: 4B\n*/\n\n#include<iostream>\nusing namespace std;\n\nint main(int argc, char ** argv) {\n\tint size_square, size_border, color_square, color_border;\n\tdo {\n\t\tcout << "Enter the size of the square: ";\n\t\tcin >> size_square;\n\t\tif (size_square < 0) {\n\t\t\tcout << "Invalid input!\\n";\n\t\t}\n\t} \n\twhile (size_square < 0);\n\t\n\tdo {\n\t\tcout << "Enter the size of the border: ";\n\t\tcin >> size_border;\n\t\tif (size_border < 0) {\n\t\t\tcout << "Invalid input!\\n";\n\t\t}\n\t} \n\twhile (size_square < 0);\n\t\n\tdo {\n\t\tcout << "Enter the color of the square: ";\n\t\tcin >> color_square;\n\t\tif (!(color_square == 0 || color_square == 1)) {\n\t\t\tcout << "Invalid input!\\n";\n\t\t}\n\t} \n\twhile (!(color_square == 0 || color_square == 1));\n\t\n\tdo {\n\t\tcout << "Enter the color of the border: ";\n\t\tcin >> color_border;\n\t\tif (!(color_border == 0 || color_border == 1)) {\n\t\t\tcout << "Invalid input!\\n";\n\t\t}\n\t} \n\twhile (!(color_border == 0 || color_border == 1));\n\n\tcout << "PBM File Contents:\\nP1\\n";\n\tint dim = (2 * size_border) + size_square;\n\tcout << dim << \' \' << dim << \'\\n\'; \n\t// top border\n\tfor (int h = 0; h < size_border; h++) {\n\t\tfor (int corner = 0; corner < size_border; corner++) {\n\t\t\tcout << color_border << \' \';\n\t\t}\n\t\tfor (int middle = 0; middle < size_square; middle++) {\n\t\t\tcout << color_border << \' \';\t\n\t\t}\n\t\tfor (int corner = 0; corner < size_border; corner++) {\n\t\t\tcout << color_border << \' \';\n\t\t}\n\t\tcout << \'\\n\';\n\t}\n\n\t// Middle [border][content][border]\n\tfor (int h = 0; h < size_square; h++) {\n\t\tfor (int border = 0; border < size_border; border++) {\n\t\t\tcout << color_border << \' \';\n\t\t}\n\t\tfor (int content = 0; content < size_square; content++) {\n\t\t\tcout << color_square << \' \';\n\t\t}\n\t\tfor (int border = 0; border < size_border; border++) {\n\t\t\tcout << color_border << \' \';\n\t\t}\n\t\tcout << \'\\n\';\n\t}\n\t\n\t// bottom border\n\tfor (int h = 0; h < size_border; h++) {\n\t\tfor (int corner = 0; corner < size_border; corner++) {\n\t\t\tcout << color_border << \' \';\n\t\t}\n\t\tfor (int middle = 0; middle < size_square; middle++) {\n\t\t\tcout << color_border << \' \';\t\n\t\t}\n\t\tfor (int corner = 0; corner < size_border; corner++) {\n\t\t\tcout << color_border << \' \';\n\t\t}\n\t\tcout << \'\\n\';\n\t}\n\n\n\treturn 0;\n}\n'}, {'name': 'Assignment5A.cpp', 'language': 'C++', 'contents': '/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring \'23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nAssignment#: 5A: Hospital Directory\n*/\n#include <iostream>\nusing namespace std;\n\n// Global DB: \nstring g_first_names[5] = {"Mark", "Amanda", "Norman", "Steve", "Jesse"};\nstring g_last_names[5] = {"Sloan", "Bentley", "Briggs", "Sloan", "Travis"};\nint g_ages[5] = {67, 33, 47, 35, 24};\nstring g_occupations[5] = {"Chief of Internal Medicine", "Pathologist",\n\t"Administrator", "Hospital Security", "Surgeon Intern"};\nbool g_has_license[5] = {true, true, false, false, true};\n\nvoid print_employee(int id) {\n\tcout << \'#\' << id << ": " << g_first_names[id] << \' \' << \n\t\tg_last_names[id] << ", Age " << g_ages[id] << ", "\n\t\t<< g_occupations[id] << ", Medical License: ";\n\tif (g_has_license[id]) {\n\t\tcout << "TRUE\\n";\n\t} else {\n\t\tcout << "FALSE\\n";\n\t}\n}\n\nint main(int argc, char ** argv) {\n\tcout << "[Community General Hospital Directory]\\n";\n\n\tint selection;\n\t\n\twhile (selection != 4) {\n\t\tcout << "1) List all employees\\n";\n\t\tcout << "2) Search employee records by ID\\n";\n\t\tcout << "3) Search employee records by Last Name\\n";\n\t\tcout << "4) Quit\\n";\n\t\tcout << "Choice: ";\n\t\tcin >> selection;\n\t\t\n\t\tswitch (selection) {\n\t\t\tcase 1: \n\t\t\t\tfor (int id=0; id<5; id++) {\n\t\t\t\t\tprint_employee(id);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\t{\n\t\t\t\t\tint id;\n\t\t\t\t\tbool valid_id = false;\n\t\t\t\t\twhile (!valid_id) {\n\t\t\t\t\t\tcout << "ID: ";\n\t\t\t\t\t\tcin >> id;\n\t\t\t\t\t\tif (id >= 0 && id <= 4) {\n\t\t\t\t\t\t\tvalid_id = true;\t\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcout << "Invalid ID!\\n";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tprint_employee(id);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase 3: \n\t\t\t\t{\n\t\t\t\t\tstring last_name;\n\t\t\t\t\tcout << "Last Name: ";\n\t\t\t\t\tcin >> last_name;\n\t\t\t\t\tbool found = false;\n\t\t\t\t\tfor (int id=0; id<5; id++) {\n\t\t\t\t\t\tif (g_last_names[id] == last_name) {\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\tprint_employee(id);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (found == false) {\n\t\t\t\t\t\tcout << "No Records Found!\\n";\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase 4: \n\t\t\t\tcout << "[Closing Directory...]\\n";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcout << "No option " << selection << "!\\n";\n\t\t\t\tbreak;\n\t\t}\n\t\tcout << \'\\n\';\n\t}\n\t\n\treturn 0;\n}\n\n'}, {'name': 'Assignment5B.cpp', 'language': 'C++', 'contents': '/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring \'23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nAssignment#: 5B Art Program\n*/\n\n#include <iostream>\nusing namespace std;\n\nint main(int argc, char ** argv) {\n\tcout << "[KSU Image Manipulation Program]\\n";\n\tint width, height, fill_color, selection;\n\tcout << "Enter an image width: ";\n\tcin >> width;\n\tcout << "Enter an image height: ";\n\tcin >> height;\n\tcout << "Enter the fill color: ";\n\tcin >> fill_color;\n\n\t// initialize image\n\tint image[width][height] = {};\n\tfor (int i=0; i < height; i++) {\n\t\tfor (int j=0; j < width; j++) {\n\t\t\timage[i][j] = fill_color;\n\t\t}\n\t}\n\n\twhile (selection!= 4) {\n\t\tcout << "What will you do?\\n";\n\t\tcout << "1) Fill in a pixel\\n";\n\t\tcout << "2) Fill in a line\\n";\n\t\tcout << "3) Print the image\\n";\n\t\tcout << "4) Quit\\n";\n\t\tcout << "Choice? ";\n\t\tcin >> selection;\n\n\t\tswitch (selection) {\n\t\t\tcase 1: \n\t\t\t\t{\n\t\t\t\t\tint row, col, new_color;\n\t\t\t\t\tbool valid_replacement = false;\n\t\t\t\t\twhile (!valid_replacement) {\n\t\t\t\t\t\tcout << "\\nRow: ";\n\t\t\t\t\t\tcin >> row;\n\t\t\t\t\t\tcout << "Column: ";\n\t\t\t\t\t\tcin >> col;\n\t\t\t\t\t\tcout << "New Color: ";\n\t\t\t\t\t\tcin >> new_color;\n\t\t\t\t\t\tif (row <= width && col <= height && (new_color >= 0 && new_color <= 255)) {\n\t\t\t\t\t\t\tvalid_replacement = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcout << "Invalid information!";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\timage[row][col] = new_color;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase 2: \n\t\t\t\t{\n\t\t\t\t\tint row, col, new_color, length;\n\t\t\t\t\tstring direction;\n\t\t\t\t\tbool valid_replacement = false;\n\t\t\t\t\twhile (!valid_replacement) {\n\t\t\t\t\t\tcout << "\\nRow: ";\n\t\t\t\t\t\tcin >> row;\n\t\t\t\t\t\tcout << "Column: ";\n\t\t\t\t\t\tcin >> col;\n\t\t\t\t\t\tcout << "New Color: ";\n\t\t\t\t\t\tcin >> new_color;\n\t\t\t\t\t\tcout << "Length: ";\n\t\t\t\t\t\tcin >> length;\n\t\t\t\t\t\tcout << "Direction: ";\n\t\t\t\t\t\tcin.ignore();\n\t\t\t\t\t\tgetline(cin, direction);\n\n\n\t\t\t\t\t\t// have to perform bounds check on line to avoid potentially \n\t\t\t\t\t\t// overwriting memory we don\'t have access to \n\t\t\t\t\t\tbool valid_line;\n\t\t\t\t\t\tif (direction == "up") {\n\t\t\t\t\t\t\tvalid_line = ((row+1) - length >=0);\n\t\t\t\t\t\t} else if (direction == "down") {\n\t\t\t\t\t\t\tvalid_line = ((row+1) + length <= height);\t\n\t\t\t\t\t\t} else if (direction == "right") {\n\t\t\t\t\t\t\tvalid_line = ((col+1) - length >= 0);\n\t\t\t\t\t\t} else if (direction == "left") {\n\t\t\t\t\t\t\tvalid_line = ((col+1) + length <= width);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (row <= width && col <= height && (new_color >= 0 && new_color <= 255) && valid_line) {\n\t\t\t\t\t\t\tvalid_replacement = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcout << "Invalid information!";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (direction == "up") {\n\t\t\t\t\t\tfor (int j=0; j <= length; j++) {\n\t\t\t\t\t\t\timage[row-j][col] = new_color;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (direction == "down") {\n\t\t\t\t\t\tfor (int j=0; j <= length; j++) {\t\n\t\t\t\t\t\t\timage[row+j][col] = new_color;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (direction == "right") {\n\t\t\t\t\t\tfor (int i=0; i <= length; i++) {\n\t\t\t\t\t\t\timage[row][col+i] = new_color;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (direction == "left") {\n\t\t\t\t\t\tfor (int i=0; i <= length; i++) {\n\t\t\t\t\t\t\timage[row][col-i] = new_color;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase 3:\n\t\t\t\t{\n\t\t\t\t\tcout << "\\nPGM Image Contents\\n";\n\t\t\t\t\tcout << "P2\\n";\n\t\t\t\t\tcout << width << \' \' << height << \'\\n\';\n\t\t\t\t\tcout << "255\\n";\n\t\t\t\t\tfor (int i=0; i < height; i++) {\n\t\t\t\t\t\tfor (int j=0; j < width; j++) {\n\t\t\t\t\t\t\tcout << image[i][j] << \' \'; \n\t\t\t\t\t\t}\n\t\t\t\t\t\tcout << \'\\n\';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase 4: \n\t\t\t\tcout << "\\n[Exiting KSU Image Manipulation Program]";\n\t\t\t\tbreak;\n\t\t\tdefault: \n\t\t\t\tcout << "No option " << selection << "!\\n";\n\t\t\t\tbreak;\n\t\t}\n\t\tcout << \'\\n\';\n\t}\n\t\n\treturn 0;\n}\n'}, {'name': 'Assignment6A.cpp', 'language': 'C++', 'contents': '/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring \'23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nAssignment#: 6A: Benchmark Test for Searching\n*/\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main(int argc, char ** argv) {\n\tconst int length = 1000019;\n\tint* arr = new int[length];\n\tfor (int i = 0; i < length; i++) {\n\t\tarr[i] = length - i;\n\t}\n\n\tsrand(time(NULL));\n\tint target = rand() % length;\n\n\tcout << "[Linear Vs. Binary Search] \\n";\n\tcout << "The target value is " << target << \'\\n\';\n\n\t// Linear Search\n\tint linear_counter = 0;\n\tfor (int search = length-1; search >= 0; search--) {\n\t\tlinear_counter++;\n\t\tif (arr[search] == target) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t}\n\n\t// Binary Search\n\tint binary_counter = 0;\n\tbool found = false;\t\n\tint low = 0;\n\tint mid;\n\tint high = length - 1;\n\tdo {\n\t\tbinary_counter++;\n\t\tmid = (high + low)/2;\n\t\tif (arr[mid] == target) {\n\t\t\tlow = high;\n\t\t} else if (arr[mid] < target) {\n\t\t\thigh = mid -1;\n\t\t} else {\n\t\t\tlow = mid + 1;\n\t\t}\n\t} \n\twhile (low < high);\n\n\tcout << "Linear Search: " << linear_counter << " loop(s)\\n";\n\tcout << "Binary Search: " << binary_counter << " loop(s)\\n";\n\tif (linear_counter < binary_counter) {\n\t\tcout << "Linear Search is faster this time!\\n";\n\t} else if (binary_counter < linear_counter) {\n\t\tcout << "Binary Search is faster this time!\\n";\n\t} else {\n\t\tcout << "Linear and Binary search took the same amount of iterations!\\n";\n\t}\n\t\n\treturn 0;\n}\n'}, {'name': 'Assignment6B.cpp', 'language': 'C++', 'contents': '/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring \'23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nAssignment#: 6B: Random Sort \n*/\n\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint g_count = 0;\n\nbool check_if_sorted(int *arr) {\n\tbool sorted = true;\n\n\tfor (int i = 0; i < 16; i++) {\n\t\tif (arr[i] > arr[i+1]) {\n\t\t\tsorted = false;\t\n\t\t} \n\t}\n\tif (sorted) {\n\t\tcout << "Hooray, it\'s sorted! And it only took " << g_count << \n\t\t\t"attempts!\\n";\n\t}\n\treturn sorted;\n}\n\nint* shuffle_array(int *arr) {\n\tcout << "\\nShuffling array...\\n";\n\tstd::random_shuffle(arr, arr+17);\n\treturn arr;\n}\n\nvoid print_array(int *arr) {\n\tcout << "\\nPrinting array...\\n";\n\tfor (int i = 0; i < 17; i++) {\n\t\tcout << arr[i] << ", ";\n\t}\n\tcout << \'\\n\';\n\n\tif (!check_if_sorted(arr)) {\n\t\tcout << "Not sorted yet!\\n";\n\t}\n}\n\nint main(int argc, char ** argv) {\n\tint arr[17];\n\tsrand(int(NULL));\n\tfor (int i = 0; i < 17; i++) {\n\t\tarr[i] = rand() % 359;\n\t}\n\t\n\tcout << "[Random Sort]\\n";\n\tprint_array(arr);\n\tdo{\n\t\tg_count++;\n\t\tshuffle_array(arr);\n\t\tprint_array(arr);\n\t} \n\twhile (!check_if_sorted(arr));\n\t\n\treturn 0;\n}\n'}, {'name': 'Assignment6C.cpp', 'language': 'C++', 'contents': '/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring \'23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nAssignment#: 6C: Overloaded Functions\n*/\n\n\n\nint main(int argc, char ** argv) {\n\tcout << "[Overloaded Surprise Function]\\n";\n\tcout << "What data type do you want to enter? ";\n\tstring selection = cin.getline();\n\tif (selection == "char") {\n\t\tchar v1, v2;\t\n\t} else if (selection == "boolean") {\n\t\tbool v1, v2;\n\t} else if (selection == "float") {\n\t\tfloat v1, v2;\n\t} else if (selection == "integer") {\n\t\tint v1, v2;\n\t} else if (selection == "double") {\n\t\tdouble v1, v2;\n\t}\n\treturn 0;\n}\n'}, {'name': 'Assignment7A.cpp', 'language': 'C++', 'contents': '/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring \'23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nAssignment#: 7A: Ro-Sham-Bo \n*/\n\n#include <iostream>\n#include <stdlib.h>\n#include <boost/algorithm/string/predicate.hpp>\nusing namespace std;\n\nclass RoshamboPlayer {\npublic: \n\tstring m_playerName {};\n\t//string m_attack {};\n\tint m_roLimit {};\n\tint m_shamBoLimit {};\n\n\tRoshamboPlayer(string name, int roLimit, int shamBoLimit) {\n\t\tm_playerName = name;\n\t\tm_roLimit = roLimit;\n\t\tm_shamBoLimit = shamBoLimit;\n\t}\n\n\tbool playRound(string playerAttack, string opponentAttack) {\n\t\t// Rock\n\t\tif (boost::iequals("Ro", playerAttack)) {\n\t\t\tif (boost::iequals("Ro", opponentAttack)) {\n\t\t\t\t// draw\n\t\t\t\treturn false;\n\t\t\t} else if (boost::iequals("Sham", opponentAttack)) {\n\t\t\t\treturn false;\n\t\t\t} else if (boost::iequals("Bo", opponentAttack)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t// Paper\n\t\t} else if (boost::iequals("Sham", playerAttack)) {\n\t\t\tif (boost::iequals("Ro", opponentAttack)) {\n\t\t\t\treturn true;\n\t\t\t} else if (boost::iequals("Sham", opponentAttack)) {\n\t\t\t\t// draw\n\t\t\t\treturn false;\n\t\t\t} else if (boost::iequals("Bo", opponentAttack)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t// Scissors\n\t\t} else  if (boost::iequals("Bo", playerAttack)) {\n\t\t\tif (boost::iequals("Ro", opponentAttack)) {\n\t\t\t\treturn false;\n\t\t\t} else if (boost::iequals("Sham", opponentAttack)) {\n\t\t\t\treturn true;\n\t\t\t} else if (boost::iequals("Bo", opponentAttack)) {\n\t\t\t\t// draw\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t} \n\n\t\t// should not be reachable, given input sanitization but needs to be here\n\t\t// for compilation reasons\n\t\treturn false;\n\t}\n\n\tstring getName() { return m_playerName; }\n\n\tstring getAttack() { \n\t\tstring attack;\n\t\tint rand_num = rand() % 100;\n\t\tif (rand_num <= m_roLimit) {\n\t\t\tattack = "Ro";\n\t\t} else if (rand_num <= m_shamBoLimit) {\n\t\t\tattack = "Sham";\n\t\t} else {\n\t\t\tattack = "Bo";\n\t\t}\n\t\treturn attack;\n\t}\n};\n\nbool validString(string test) {\n\tif (boost::iequals("ro", test)) {\n\t\treturn true;\n\t} else if (boost::iequals("sham", test)) {\n\t\treturn true;\n\t} else if (boost::iequals("bo", test)) {\n\t\treturn true;\n\t} else {\n\t\tcout << "Invalid attack!\\n";\n\t\treturn false;\n\t}\n}\n\nint main(int argc, char ** argv) {\n\t// init rand seed\n\tsrand(time(NULL));\n\n\tcout << "[Ro-Sham-Bo Player]\\n";\n\tcout << "Who do you want to face?\\n";\n\n\tRoshamboPlayer p1{"R. Dorothy", 30, 60};\n\tRoshamboPlayer p2{"Johnny 5", 40, 85};\n\tint opponent;\n\tcout << "1) R. Dorothy\\n";\n\tcout << "2) Johnny 5\\n";\n\tcout << "Opponent: ";\n\tcin >> opponent;\n\n\tbool quit = false;\n\tif (opponent == 1) {\n\t\tcout << "\\nYour opponent is R. Dorothy\\n";\n\t\tdo {\n\t\t\tint selection;\n\t\t\tcout << "1) Play a round?\\n";\n\t\t\tcout << "2) Quit?\\n";\n\t\t\tcout << "Choice: ";\n\t\t\tcin >> selection;\n\t\t\tif (selection == 2) {\n\t\t\t\tquit = true;\n\t\t\t} else {\n\t\t\t\tbool valid_string = false;\n\t\t\t\tstring attack;\n\t\t\t\tdo {\n\t\t\t\t\tcout << "\\nEnter an attack: ";\n\t\t\t\t\tcin.ignore();\n\t\t\t\t\tgetline(cin, attack);\n\t\t\t\t\tvalid_string = validString(attack);\n\t\t\t\t}\n\t\t\t\twhile (!valid_string);\n\t\t\t\t\n\t\t\t\tstring opponentAttack = p1.getAttack();\n\t\t\t\tbool victory = p1.playRound(attack, opponentAttack);\n\t\t\t\tcout << p1.getName() << " chose " << opponentAttack\n\t\t\t\t\t<< "! You ";\n\t\t\t\tif (victory) {\n\t\t\t\t\tcout << "win!\\n";\n\t\t\t\t} else {\n\t\t\t\t\tcout << "lose...\\n"; \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (!quit);\n\t} else {\n\t\tcout << "\\nYour opponent is Johnny 5\\n";\n\t\tdo {\n\t\t\tint selection;\n\t\t\tcout << "1) Play a round?\\n";\n\t\t\tcout << "2) Quit?\\n";\n\t\t\tcin >> selection;\n\t\t\tif (selection == 2) {\n\t\t\t\tquit = true;\n\t\t\t} else {\n\t\t\t\tbool valid_string = false;\n\t\t\t\tstring attack;\n\t\t\t\tdo {\n\t\t\t\t\tcout << "\\nEnter an attack: ";\n\t\t\t\t\tcin.ignore();\n\t\t\t\t\tgetline(cin, attack);\n\t\t\t\t\tvalid_string = validString(attack);\n\t\t\t\t}\n\t\t\t\twhile (!valid_string);\n\t\t\t\t\n\t\t\t\tstring opponentAttack = p2.getAttack();\n\t\t\t\tbool victory = p2.playRound(attack, opponentAttack);\n\t\t\t\tcout << p2.getName() << " chose " << opponentAttack\n\t\t\t\t\t<< "! You ";\n\t\t\t\tif (victory) {\n\t\t\t\t\tcout << "win!\\n"; \n\t\t\t\t} else {\n\t\t\t\t\tcout << "lose...\\n"; \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (!quit);\n\t}\n\t\n\tcout << "Game Over\\n";\t\n\treturn 0;\n}\n'}, {'name': 'Assignment7B.cpp', 'language': 'C++', 'contents': '/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring \'23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nAssignment#: 7B: Color Art Program\n*/\n\n#include <iostream>\nusing namespace std;\n\nclass Pixel {\npublic:\n\tint m_red {};\n\tint m_green {};\n\tint m_blue {};\n\n\tPixel() {\n\t\tm_red = 255;\n\t\tm_green = 255;\n\t\tm_blue = 255;\n\t}\n\n\tPixel(int red, int green, int blue) {\n\t\tm_red = red;\n\t\tm_green = green;\n\t\tm_blue = blue;\n\t}\n\n\tvoid changeRGB(int red, int green, int blue) {\n\t\tm_red = red;\n\t\tm_green = green;\n\t\tm_blue = blue;\n\t}\n\n\tvoid printRGB() {\n\t\tcout << m_red << \' \' << m_green << \' \' << m_blue;\n\t}\n\n\n\n};\n\nint main(int argc, char ** argv) {\n\tcout << "[Color Art Program]\\n";\n\tint width, height, fill_red, fill_green, fill_blue, selection;\n\tcout << "Enter an image width: ";\n\tcin >> width;\n\tcout << "Enter an image height: ";\n\tcin >> height;\n\tcout << "Enter the fill color\'s red value: ";\n\tcin >> fill_red;\n\tcout << "Enter the fill color\'s green value: ";\n\tcin >> fill_green;\n\tcout << "Enter the fill color\'s blue value: ";\n\tcin >> fill_blue;\n\n\t// Initialize image\n\tPixel image[width][height] = {};\n\tfor (int i=0; i < height; i++) {\n\t\tfor (int j=0; j < width; j++) {\n\t\t\timage[i][j] = Pixel{fill_red, fill_green, fill_blue};\n\t\t}\n\t}\n\n\n\tbool quit = false;\n\n\tdo {\n\t\tcout << "\\nWhat will you do?\\n";\n\t\tcout << "1) Fill in a pixel\\n";\n\t\tcout << "2) Fill in a line\\n";\n\t\tcout << "3) Print the image\\n";\n\t\tcout << "4) Quit\\n";\n\t\tcout << "Choice? ";\n\t\tcin >> selection;\n\n\t\tswitch (selection) {\n\t\t\tcase 1: \n\t\t\t\t{\n\t\t\t\t\tint row, col, new_red, new_blue, new_green;\n\t\t\t\t\tbool valid_replacement = false;\n\t\t\t\t\twhile(!valid_replacement) {\n\t\t\t\t\t\tcout << "\\nRow: ";\n\t\t\t\t\t\tcin >> row;\n\t\t\t\t\t\tcout << "Column: ";\n\t\t\t\t\t\tcin >> col;\n\t\t\t\t\t\tcout << "New Red Color: ";\n\t\t\t\t\t\tcin >> new_red;\n\t\t\t\t\t\tcout << "New Blue Color: ";\n\t\t\t\t\t\tcin >> new_blue;\n\t\t\t\t\t\tcout << "New Green Color: ";\n\t\t\t\t\t\tcin >> new_green;\n\t\t\t\t\t\tif (row <= width && col <= height && \n\t\t\t\t\t\t\t\t(new_red >= 0 && new_red <= 255) &&\n\t\t\t\t\t\t\t\t(new_green >= 0 && new_green <= 255) &&\n\t\t\t\t\t\t\t\t(new_blue >= 0 && new_blue <= 255)) {\n\t\t\t\t\t\t\tvalid_replacement = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcout << "Invalid information!";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\timage[row][col] = Pixel{new_red, new_green, new_blue};\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase 2:\n\t\t\t\t{\n\t\t\t\t\tint row, col, new_red, new_green, new_blue, length;\n\t\t\t\t\tstring direction;\n\t\t\t\t\tbool valid_replacement = false;\n\t\t\t\t\twhile (!valid_replacement) {\n\t\t\t\t\t\tcout << "\\nRow: ";\n\t\t\t\t\t\tcin >> row;\n\t\t\t\t\t\tcout << "Column: ";\n\t\t\t\t\t\tcin >> col;\n\t\t\t\t\t\tcout << "New Red Color: ";\n\t\t\t\t\t\tcin >> new_red;\n\t\t\t\t\t\tcout << "New Green Color: ";\n\t\t\t\t\t\tcin >> new_green;\n\t\t\t\t\t\tcout << "New Blue Color: ";\n\t\t\t\t\t\tcin >> new_blue;\n\t\t\t\t\t\tcout << "Length: ";\n\t\t\t\t\t\tcin >> length;\n\t\t\t\t\t\tcout << "Direction: ";\n\t\t\t\t\t\tcin.ignore();\n\t\t\t\t\t\tgetline(cin, direction);\n\n\t\t\t\t\t\t// We have to perform bounds checks on line to avoid potentially\n\t\t\t\t\t\t// overwriting memory we don\'t have access to\n\t\t\t\t\t\tbool valid_line;\n\t\t\t\t\t\tif (direction == "up") {\n\t\t\t\t\t\t\tvalid_line = ((row+1) - length >= 0);\n\t\t\t\t\t\t} else if (direction == "down") {\n\t\t\t\t\t\t\tvalid_line = ((row+1) + length <= height);\n\t\t\t\t\t\t} else if (direction == "right") {\n\t\t\t\t\t\t\tvalid_line = ((col+1) - length >= 0);\n\t\t\t\t\t\t} else if (direction == "left") {\n\t\t\t\t\t\t\tvalid_line = ((col+1) + length <= width);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (row <= width && col <= height && \n\t\t\t\t\t\t\t\t(new_red >= 0 && new_red <= 255) &&\n\t\t\t\t\t\t\t\t(new_green >= 0 && new_green <= 255) &&\n\t\t\t\t\t\t\t\t(new_blue >= 0 && new_blue <= 255) &&\n\t\t\t\t\t\t\t\tvalid_line) {\n\t\t\t\t\t\t\tvalid_replacement = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcout << "Invalid information!";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (direction == "up") {\n\t\t\t\t\t\tfor (int j=0; j <= length; j++) {\n\t\t\t\t\t\t\timage[row-j][col] = Pixel{new_red, new_green, new_blue};\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (direction == "down") {\n\t\t\t\t\t\tfor (int j=0; j<= length; j++) {\n\t\t\t\t\t\t\timage[row+j][col] = Pixel{new_red, new_green, new_blue};\n\t\t\t\t\t\t}\n\t\t\n\t\t\t\t\t} else if (direction == "right") {\n\t\t\t\t\t\tfor (int i=0; i <= length; i++) {\n\t\t\t\t\t\t\timage[row][col+i] = Pixel{new_red, new_green, new_blue};\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (direction == "left") {\n\t\t\t\t\t\tfor (int i=0; i <= length; i++) {\n\t\t\t\t\t\t\timage[row][col-1] = Pixel{new_red, new_green, new_blue};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase 3:\n\t\t\t\t{\n\t\t\t\t\tcout << "\\nPGM Image Contents\\n";\n\t\t\t\t\tcout << "P3\\n";\n\t\t\t\t\tcout << width << \' \' << height << \'\\n\';\n\t\t\t\t\tcout << "255\\n";\n\t\t\t\t\tfor (int i=0; i < height; i++) {\n\t\t\t\t\t\tfor (int j=0; j < width; j++) {\n\t\t\t\t\t\t\timage[i][j].printRGB();\n\t\t\t\t\t\t\tcout << \' \';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcout << \'\\n\';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase 4:\n\t\t\t\t{\n\t\t\t\t\tcout << "\\n[Exiting Color Art Program]";\n\t\t\t\t\tquit = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tdefault: \n\t\t\t\tcout << "No option " << selection << "!\\n";\n\t\t\t\tbreak;\n\t\t}\n\t\tcout << \'\\n\';\n\t\t\n\t}\n\twhile (!quit);\n\t\n\treturn 0;\n}\n'}, {'name': 'assignment7C.cpp', 'language': 'C++', 'contents': "/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring '23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nAssignment#:  \n*/\n\nint main(int argc, char ** argv) {\n\t\n\treturn 0;\n}\n"}, {'name': 'Lab1A.cpp', 'language': 'C++', 'contents': '/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring \'23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nLab#: 1\n*/\n\n// Lab1A\n// Demonstrate the difference of include endl (endline)\n// Prints two lines of output representing a rocket countdown\n\n#include <iostream>\nusing namespace std;\n\nint main(int argc, char ** ** argv) {\n\tcout << "Three... ";\n\tcout << "Two... ";\n\tcout << "One... ";\n\tcout << "Zero ... ";\n\tcout << "Liftoff!" << endl;\n\t// appears on the first line\n\tcout << "Houston, we have a problem." << endl << endl;\n\treturn 0;\n}\n\n'}, {'name': 'Lab1B.cpp', 'language': 'C++', 'contents': '/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring \'23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nLab#: 1\n*/\n\n// Lab1B\n// Demonstrate reading a string from the user.\n// Reads a character string from the user and prints it. \n\n#include <string>\n#include <iostream>\nusing namespace std;\n\nint main(int argc, char ** argv) {\n\tstring message;\n\tcout << "Enter a line of text: ";\n\tgetline(cin, message);\n\tcout << "You wrote \'" << message << "\'" << endl;\n\treturn 0;\n}\n\n'}, {'name': 'Lab1C.cpp', 'language': 'C++', 'contents': '/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring \'23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nLab#: 1\n*/\n\n// Lab1C\n// Demonstrate the use of the cin, or the standard input stream to read numeric\n// data\n// Calculates fuel efficiency based on values entered by the user.\n\n#include <iostream>\nusing namespace std;\n\nint main(int argc, char ** argv) {\n\tint miles;\n\tdouble gallons, mpg;\n\tcout << "Enter the number of miles: ";\n\tcin >> miles;\n\n\tcout << "Enter the gallons of fuel used: ";\n\tcin >> gallons;\n\n\tmpg = miles / gallons;\n\tcout << "Miles Per Gallon: " << mpg << endl << endl;\n\treturn 0;\n}\n\n'}, {'name': 'lab10A.cpp', 'language': 'C++', 'contents': "/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring '23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nLab#: \n*/\n\nint main(int argc, char ** argv) {\n\n\treturn 0;\n}\n"}, {'name': 'lab10B.cpp', 'language': 'C++', 'contents': "/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring '23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nLab#: \n*/\n\nint main(int argc, char ** argv) {\n\n\treturn 0;\n}\n"}, {'name': 'lab10C.cpp', 'language': 'C++', 'contents': "/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring '23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nLab#: \n*/\n\nint main(int argc, char ** argv) {\n\n\treturn 0;\n}\n"}, {'name': 'Lab11A.cpp', 'language': 'C++', 'contents': '/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring \'23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nLab#: 11A\n*/\n\n#include <iostream>\n#include <boost/algorithm/string.hpp>\nusing namespace std;\n\nint main(int argc, char ** argv) {\n\tbool cont = true;\n\tdo {\n\t\tcout << "Menu\\n";\n\t\tint selection;\n\t\tcout << "0) Hello World\\n";\n\t\tcout << "1) Goodbye Moon\\n";\n\t\tcout << "2) Walking on Sunshine\\n";\n\t\tcout << "\\nWhat would you like to do: ";\n\t\tcin >> selection;\n\t\tswitch (selection) {\n\t\t\tcase 0:\n\t\t\t\tcout << "\\nHello!\\n";\n\t\t\t\tbreak;\n\t\t\tcase 1: \n\t\t\t\tcout << "\\nOk, bye.\\n";\n\t\t\t\tbreak;\n\t\t\tcase 2: \n\t\t\t\tcout << "\\nWHOA!\\n";\n\t\t\t\tbreak;\n\t\t}\n\t\tcin.ignore();\n\t\tstring decision;\n\t\tcout << "\\nType YES to rerun. ";\n\t\tgetline(std::cin, decision);\n\t\tcont = boost::iequals(decision, "yes");\n\t\tcout << \'\\n\';\n\t}\n\twhile (cont);\n\n\tcout << "Program Ends\\n";\n\n\treturn 0;\n}\n'}, {'name': 'Lab11B.cpp', 'language': 'C++', 'contents': '/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring \'23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nLab#: 11B\n*/\n\n#include <iostream>\nusing namespace std;\n\nint main(int argc, char ** argv) {\n\tbool eight_chars = false;\n\tbool has_upper = false;\n\tbool has_digit = false;\n\tstring password;\n\tcout << "Enter a password: ";\n\tgetline(cin, password);\n\n\tint char_count = 0;\n\tfor (char& c : password) {\n\t\tchar_count++;\n\t\tint ascii_value = (int) c;\n\t\tif ((c >= 65) && (c <= 90)) {\n\t\t\thas_upper = true;\n\t\t} else if ((c >= 48) && (c <= 57)) {\n\t\t\thas_digit = true;\n\t\t}\n\t}\n\tif (char_count >= 7) {\n\t\teight_chars = true;\n\t}\n\n\tbool valid_pw = (eight_chars && has_upper && has_digit); \n\n\tif (valid_pw) {\n\t\tcout << "Valid password\\n";\n\t} else {\n\t\tcout << "Invalid password\\n";\n\t}\n\n\tcout << "\\nProgram Ends\\n";\n\n\n\treturn 0;\n}\n'}, {'name': 'Lab12A.cpp', 'language': 'C++', 'contents': '/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring \'23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nLab#: A Tale of Two Classes\n*/\n\n#include <iostream>\n#include <boost/algorithm/string.hpp>\nusing namespace std;\n\nclass Chair {\n\tpublic:\t\n\t\tint num_of_legs {};\n\t\tbool rolling {};\n\t\tstring material{};\n};\n\nclass Lab12A {\n\tpublic: \n\t\tvoid main() {\n\t\t\tint legs;\n\t\t\tstring rolls_tmp;\n\t\t\tbool rolls;\n\t\t\tstring mat;\n\t\t\tcout << "You are about to create a chair.\\n";\n\t\t\tcout << "How many legs does your chair have: ";\n\t\t\tcin >> legs;\n\t\t\tcout << "Is your chair rolling (true/false): ";\n\t\t\tcin.ignore();\n\t\t\tgetline(cin, rolls_tmp);\n\t\t\tif (boost::iequals(rolls_tmp, "true")) {\n\t\t\t\trolls = true;\n\t\t\t} else {\n\t\t\t\trolls = false;\n\t\t\t}\n\t\t\tcout << "What is your chair made of: ";\n\t\t\tgetline(cin, mat);\n\t\t\tcout << "\\n";\n\n\t\t\tChair first { legs, rolls, mat };\n\n\t\t\tprint(first);\n\t\t\tcout << "\\nThis program is going to change that.\\n";\n\t\t\tfirst.num_of_legs = 4;\n\t\t\tfirst.rolling = false;\n\t\t\tfirst.material = "wood";\n\t\t\tprint(first);\n\t\t}\n\t\t\n\t\tvoid print(Chair first) {\n\t\t\tcout << "\\nYour chair has " << first.num_of_legs << " legs, ";\n\t\t\tif (first.rolling) {\n\t\t\t\tcout << "is rolling, ";\n\t\t\t} else {\n\t\t\t\tcout << "is not rolling, ";\n\t\t\t}\n\t\t\tcout << "and is made of " << first.material << ".\\n";\n\t\t}\n};\n\nint main() {\n\tLab12A driver;\n\tdriver.main();\n}\n'}, {'name': 'Lab12B.cpp', 'language': 'C++', 'contents': '/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring \'23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nLab#: 12B: My dog can do tricks\n*/\n\n#include <iostream>\nusing namespace std;\n\nclass Dog {\n\tpublic: \n\t\tint age {};\n\t\tdouble weight {};\n\t\tstring name {};\n\t\tstring fur_color{};\n\t\tstring breed {};\n\n\t\tvoid bark() {\n\t\t\tcout << "\\nWoof! Woof!\\n";\n\t\t}\t\n\n\t\tvoid rename(string new_name) {\n\t\t\tthis->name = new_name;\n\t\t}\n\n\t\tvoid eat(double calories) {\n\t\t\tthis->weight += calories;\n\t\t}\n\n};\n\nclass Lab12B {\n\tpublic: \n\t\tvoid main() {\n\t\t\tDog dog;\n\t\t\tcout << "You are about to create a dog.\\n";\t\n\t\t\tcout << "How old is the dog: ";\n\t\t\tcin >> dog.age;\n\t\t\tcout << "How much does the dog weigh: ";\n\t\t\tcin >> dog.weight;\n\t\t\tcout << "What is the dog\'s name: ";\n\t\t\tcin.ignore();\n\t\t\tgetline(cin, dog.name);\n\t\t\tcout << "What color is the dog: ";\n\t\t\tgetline(cin, dog.fur_color);\n\t\t\tcout << "What breed is the dog: ";\n\t\t\tgetline(cin, dog.breed);\n\n\t\t\tprint(dog);\n\t\t\tdog.bark();\n\t\t\tcout << dog.name << " is hungry, how much should he eat: ";\n\t\t\tdouble tmp;\n\t\t\tcin >> tmp;\n\t\t\tdog.eat(tmp);\n\t\t\tcout << dog.name << " isn\'t a very good name. What should" \n\t\t\t\t<< " they be renamed to: ";\n\t\t\tcin.ignore();\n\t\t\tgetline(cin, dog.name);\n\t\t\tprint(dog);\n\t\t}\n\n\t\tvoid print(Dog dog) {\n\t\t\tcout << \'\\n\' << dog.name << " is a " << dog.age << " year old "\n\t\t\t\t<< dog.breed << " that weighs " << dog.weight \n\t\t\t\t<< " lbs.\\n";\n\t\t}\n\n};\n\nint main(int argc, char ** argv) {\n\tLab12B driver;\n\tdriver.main();\n\treturn 0;\n}\n'}, {'name': 'lab12C.cpp', 'language': 'C++', 'contents': "/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring '23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nLab#: \n*/\n\nint main(int argc, char ** argv) {\n\n\treturn 0;\n}\n"}, {'name': 'Lab13A.cpp', 'language': 'C++', 'contents': '/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring \'23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nLab#: 13A: The Architect\n*/\n\n#include <iostream>\nusing namespace std;\n\nclass BuildingBlueprint {\nprivate:\n\tint m_stories {};\n\tint m_apartments {};\n\tfloat m_occupancy {};\n\tbool m_full {};\n\npublic: \n\tBuildingBlueprint() {\n\t\tm_stories = 10;\n\t\tm_apartments = 20;\n\t\tm_occupancy = 1.0;\n\t\tm_full = true;\n\t}\n\n\tBuildingBlueprint(int stories, int apartments, float occupancy) {\n\t\tm_stories = stories;\n\t\tm_apartments = apartments;\n\t\tm_occupancy = occupancy;\n\t\tif (occupancy == 1.0) {\n\t\t\tm_full = true;\n\t\t} else {\n\t\t\tm_full = false;\n\t\t}\n\t}\n\n\tvoid setOccupancy(float occupancy) {\n\t\tif ((occupancy*100) >= 0 && (occupancy*100) <= 100) {\n\t\t\tm_occupancy = occupancy;\n\t\t}\n\t}\t\n\n\tint getStories() { return m_stories;}\n\tfloat getOccupancy() { return m_occupancy;}\n\tint getApartments() { return m_apartments;}\n\tbool getFull() { return m_full;}\n};\n\nint main(int argc, char ** argv) {\n\tBuildingBlueprint buildingOne;\n\tBuildingBlueprint buildingTwo{30, 30, 0.75};\n\t\n\tcout << "Year 2020:\\n";\n\tcout << "Building 1 has " << buildingOne.getStories() << " floors, " \n\t\t<< buildingOne.getApartments() << " apartments, and is " \n\t\t<< buildingOne.getOccupancy() * 100 << "\\% occupied. Full? ";\n\tbuildingOne.getFull() ? cout << " true\\n" : cout << " false\\n";\n\tcout << "Building 2 has " << buildingTwo.getStories() << " floors, " \n\t\t<< buildingTwo.getApartments() << " apartments, and is " \n\t\t<< buildingTwo.getOccupancy() * 100 << "\\% occupied. Full? ";\n\tbuildingTwo.getFull() ? cout << " true\\n" : cout << " false\\n";\n\n\tcout << "\\nMany years pass.\\n";\n\tbuildingOne.setOccupancy(0);\n\tbuildingTwo.setOccupancy(1.0);\n\n\tcout << "\\nYear 2043:\\n";\n\tcout << "Building 1 has " << buildingOne.getStories() << " floors, " \n\t\t<< buildingOne.getApartments() << " apartments, and is " \n\t\t<< buildingOne.getOccupancy() * 100 << "\\% occupied. Full? ";\n\tbuildingTwo.getFull() ? cout << " true\\n" : cout << " false\\n";\n\tcout << "Building 2 has " << buildingTwo.getStories() << " floors, " \n\t\t<< buildingTwo.getApartments() << " apartments, and is " \n\t\t<< buildingTwo.getOccupancy() * 100 << "\\% occupied. Full? ";\n\tbuildingOne.getFull() ? cout << " true\\n" : cout << " false\\n";\n\n\tcout << "\\nLooks like people prefer taller buildings.\\n";\n\treturn 0;\n}\n'}, {'name': 'Lab13B.cpp', 'language': 'C++', 'contents': "/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring '23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nLab#: \n*/\n\nint main(int argc, char ** argv) {\n\n\treturn 0;\n}\n"}, {'name': 'lab13C.cpp', 'language': 'C++', 'contents': "/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring '23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nLab#: \n*/\n\nint main(int argc, char ** argv) {\n\n\treturn 0;\n}\n"}, {'name': 'Lab2A.cpp', 'language': 'C++', 'contents': '/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring \'23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nLab#: 2\n*/\n\n// Lab 2A: MadLibs\n\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint main(int argc, char ** argv) {\n\tstring name1, name2, verb, adverb;\t\t\n\tcout << "Enter a name: ";\n\tcin >> name1;\n\tcout << "Enter another name: ";\n\tcin >> name2;\n\tcout << "Enter a verb: ";\n\tcin >> verb;\n\tcout << "Enter an adverb: ";\n\tcin >> adverb;\n\n\tcout << "Once upon a time, there was a person named " << name1 << \n\t\t" who had a child named " << name2 << ". This child would " << \n\t\tverb << \' \' <<  adverb  << " while singing to strangers." << \n\t\t\'\\n\';\n\n\treturn 0;\n}\n'}, {'name': 'Lab2B.cpp', 'language': 'C++', 'contents': '/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring \'23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nLab#: 2 \n*/\n\n// Lab 2B\n\n#include <iostream>\nusing namespace std;\n\nint main(int argc, char ** argv) {\n\tcout << "___*___\\n__*_*__\\n_*_*_*_\\n*_*_*_*\\n_*_*_*_\\n__*_*__\\n___*___\\n";\n\treturn 0;\n}\n'}, {'name': 'Lab2C.cpp', 'language': 'C++', 'contents': '/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring \'23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nLab#: 2\n*/\n\n// Lab 2C\n\n#include <iostream>\nusing namespace std;\n\nint main(int argc, char ** argv) {\n\tint width, height, area, perimeter;\n\tcout << "Enter a width: ";\n\tcin >> width;\n\tcout << "Enter a height: ";\n\tcin >> height;\n\tarea = width * height;\n\tperimeter = 2*(height + width);\n\tcout << "The area is " << area << \'\\n\';\n\tcout << "The perimeter is " << perimeter << \'\\n\';\n\treturn 0;\n}\n'}, {'name': 'lab3A.cpp', 'language': 'C++', 'contents': '/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring \'23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nLab#: 3A\n*/\n\n// \n// MAKE CODE PRINT PROPERLY IN REPL.IT\n//\n\n#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nint main(int argc, char ** argv) {\n\tfloat balance, apr, mpr, min_payment;\n\tcout << "Amount owed: $";\n\tcin >> balance;\n\tcout << "APR: ";\n\tcin >> apr;\n\n\tapr /= 100;\n\tmpr = (apr * 100) / 12;\n\tmin_payment = balance * apr / 12;\n\n\tcout << std::setprecision(4) << "Monthly percentage rate: " << mpr << \n\t\t\'\\n\';\n\tcout << std::setprecision(2) << fixed << "Minimum payment: $" << \n\t\tmin_payment << \'\\n\';\n\treturn 0;\n}\n'}, {'name': 'lab3B.cpp', 'language': 'C++', 'contents': '/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring \'23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nLab#: 3B\n*/\n\n// \n// MAKE THIS PRINT ON REPL.IT\n//\n\n#include<iostream>\nusing namespace std;\n\n\nint main(int argc, char ** argv) {\n\tfloat hours1, hours2, hours3, hours4, grade1, grade2, grade3, grade4;\n\t\n\tcout << "Course 1 hours; ";\n\tcin >> hours1;\n\tcout << "Grade for course 1: ";\n\tcin >> grade1;\n\n\tcout << "Course 2 hours; ";\n\tcin >> hours2;\n\tcout << "Grade for course 2: ";\n\tcin >> grade2;\n\n\tcout << "Course 3 hours; ";\n\tcin >> hours3;\n\tcout << "Grade for course 3: ";\n\tcin >> grade3;\n\n\tcout << "Course 4 hours; ";\n\tcin >> hours4;\n\tcout << "Grade for course 4: ";\n\tcin >> grade4;\n\n\tfloat total_hours, quality_points, gpa;\n\t\n\ttotal_hours = hours1 + hours2 + hours3 + hours4;\n\tquality_points = grade1*hours1 + grade2*hours2 + grade3*hours3 \n\t\t+ grade4*hours4;\n\tgpa = quality_points / total_hours; \n\n\tcout << "Total hours is: " << total_hours << \'\\n\';\n\tcout << "Total quality points: " << quality_points << \'\\n\';\n\tcout << "Your GPA for this semester is " << gpa << \'\\n\';\n\n\treturn 0;\n}\n'}, {'name': 'lab3C.cpp', 'language': 'C++', 'contents': '/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring \'23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nLab#: 3C\n*/\n\n// \n// MAKE THIS PRINT ON REPL.IT\n//\n\n#include <iostream>\nusing namespace std;\n\nint main(int argc, char ** argv) {\n\tint num_quarters, num_dimes, num_nickels, num_pennies, total_cents;\n\tfloat value_quarters, value_dimes, value_nickels, value_pennies;\n\n\tcout << "Enter the number of quarters: ";\n\tcin >> num_quarters;\n\tvalue_quarters = num_quarters * 25;\n\n\tcout << "Enter the number of dimes: ";\n\tcin >> num_dimes;\n\tvalue_dimes = num_dimes * 10;\n\n\tcout << "Enter the number of nickels: ";\n\tcin >> num_nickels;\n\tvalue_nickels = num_nickels * 5;\n\n\tcout << "Enter the number of pennies: ";\n\tcin >> num_pennies;\n\tvalue_pennies = num_pennies * 1;\n\n\ttotal_cents = value_quarters + value_dimes + value_nickels + value_pennies;\n\n\tcout << "Your total is " << total_cents / 100 << " dollars and " << \n\t\ttotal_cents % 100 << " cents.\\n"; \n\treturn 0;\n}\n'}, {'name': 'lab4A.cpp', 'language': 'C++', 'contents': '/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring \'23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nLab#: 4A\n*/\n\n// This program allows the end user to query their letter grade by parsing their\n// numerical grade\n\n#include <iostream>\nusing namespace std;\n\nint main(int argc, char ** argv) {\n\tfloat grade_num;\n\t\n\tcout << "Enter the score of your exam: ";\n\tcin >> grade_num;\n\n\n\t// Using a series of else-if statements here to check two conditions \n\t// simultaneously using the logical AND operator. Although this looks\n\t// like an opportunity to use a switch statement, you cannot use \n\t// conditionals within the cases of switch statements \n\t//\n\t// Floating point comparisons can get hairy, and require error handling\n\t// and epsilons but this code assumes some semblance of input sanitizing\n\tif (97.5 <= grade_num && grade_num <= 100) {cout << "A+\\n";}\n\telse if (94.5 <= grade_num && grade_num < 97.5) {cout << "A\\n";}\n\telse if (91.5 <= grade_num && grade_num < 94.5) {cout << "A-\\n";}\n\telse if (88.5 <= grade_num && grade_num < 91.5) {cout << "B+\\n";}\n\telse if (85.5 <= grade_num && grade_num < 88.5) {cout << "B\\n";}\n\telse if (82.5 <= grade_num && grade_num < 85.5) {cout << "B-\\n";}\n\telse if (79.5 <= grade_num && grade_num < 82.5) {cout << "C+\\n";}\n\telse if (76.5 <= grade_num && grade_num < 79.5) {cout << "C\\n";}\n\telse if (73.5 <= grade_num && grade_num < 76.5) {cout << "C-\\n";}\n\telse if (70.5 <= grade_num && grade_num < 73.5) {cout << "D+\\n";}\n\telse if (67.5 <= grade_num && grade_num < 70.5) {cout << "D\\n";}\n\telse if (64.5 <= grade_num && grade_num < 67.5) {cout << "D-\\n";}\n\telse if (0 <= grade_num && grade_num < 64.5) {cout << "F\\n";}\n\telse {cout << "Failed to parse grade.\\n";}\n\n\treturn 0;\n}\n\n'}, {'name': 'lab4B.cpp', 'language': 'C++', 'contents': '/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring \'23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nLab#: 4B\n*/\n\n// \n#include <iostream>\n#include <string>\nusing namespace std;\n\nint main(int argc, char ** argv) {\n\tstring day;\n\tcout << "Enter the day: ";\n\tcin >> day;\n\n\t// Again, this code assumes further input sanitization and would likely\n\t// benefit from corner case handling (e.g. if user inputs gibberish,\n\t// or if the capitalization is somewhere other than the first letter)\n\t// \n\t// For the first case, I would add another else-if to specifically handle\n\t// the other days. For the second case, I would include the \n\t// boost/algorithm/string/predicate.hpp header and use its iequals method\n\t// \n\t// Also, since C++ switch statements can only be used for matching ints\n\t// we use compound-conditional if statements\n\n\tif (day == "Monday" || day == "monday" || day == "Wednesday" || day == "wednesday") \n\t\t{cout << "I have class today!\\n";}\n\telse if (day == "Friday" || day == "friday")\n\t\t{cout << "It\'s Friday! Friday! Gotta get down on Friday!\\n";}\n\telse {cout << "I should use this time to do my homework.\\n";}\n\treturn 0;\n}\n'}, {'name': 'lab4C.cpp', 'language': 'C++', 'contents': '/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring \'23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nLab#: 4C\n*/\n\n#include <iostream>\nusing namespace std;\n\nint main(int argc, char ** argv) {\n\tfloat number;\n\tint selection;\n\tcout << "Welcome!\\nPlease input a number: ";\n\tcin >> number;\n\tcout << "\\nWhat would you like to do to this number: \\n0- Get the additive "\n\t\t<< " inverse of the number\\n1- Get the reciprocal inverse of the "\n\t\t<< "number\\n2- Square the number\\n3- Cube the number\\n4- Exit "\n\t\t<< "the program" << endl;\n\tcin >> selection;\n\tswitch (selection) {\n\t\tcase 0: {\n\t\t\tcout << "\\nThe additive inverse of " << number << " is "\n\t\t\t\t<< (number *= -1) << \'\\n\';\n\t\t\tbreak;\n\t\t}\n\t\tcase 1: {\n\t\t\tcout << "\\nThe reciprocal of " << number << " is " << \n\t\t\t\t(1/number) << \'\\n\';\n\t\t\tbreak;\n\t\t}\n\t\tcase 2: {\n\t\t\tcout << "\\nThe square of " << number << " is " << \n\t\t\t\t(number * number) << \'\\n\';\n\t\t\tbreak;\n\t\t}\n\t\tcase 3: {\n\t\t\tcout << "\\nThe cube of " << number << " is " << \n\t\t\t\t(number * number * number) << \'\\n\';\n\t\t\tbreak;\n\t\t}\n\t\tcase 4: {\n\t\t\tcout << "\\nThank you, goodbye!\\n"; \n\t\t\tbreak;\n\t\t}\n\t\tdefault: {\n\t\t\tcout << "\\nInvalid input, please try again!\\n";\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n'}, {'name': 'Lab5A.cpp', 'language': 'C++', 'contents': '/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring \'23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nLab#: 5A\n*/\n\n// This program determines if an applicant is eligible to buy a car\n\n#include <iostream>\nusing namespace std;\n\nint main(int argc, char ** argv) {\n\tchar response;\n\tcout << "Do you have a driving permit (Y/N)? \\n";\t\n\n\tcin >> response;\n\n\tif (response == \'N\' || response == \'n\') {\n\t\tcout << "Driving permit is a prerequisite to purchase a vehicle!\\n";\n\t} else if (response == \'Y\' || response == \'y\'){\n\t\tcout << "Do you have a commercial driving license (Y/N)?\\n";\n\t\t\n\t\tcin >> response;\n\n\t\tif (response == \'N\' || response == \'n\') {\n\t\t\tcout << "Commercial driving license is a prerequisite to "\n\t\t\t\t<< "purchase a vehicle!\\n";\n\t\t} else if (response == \'Y\' || response == \'y\') {\n\t\t\tcout << "Congratulations! You can purchase a vehicle, "\n\t\t\t\t<< "let\'s start talking options!\\n";\n\t\t} else {\n\t\t\tcout << "Failed to parse response\\n";\n\t\t}\n\t} else {\n\t\tcout << "Failed to parse response\\n";\n\t}\n\n\treturn 0;\n}\n'}, {'name': 'Lab5B.cpp', 'language': 'C++', 'contents': '/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring \'23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nLab#: 5B\n*/\n\n// This program ouputs the smallest divisor (e.g. no remainder) of an integer \n// input by the end-user\n\n#include <iostream>\nusing namespace std;\n\nstatic bool divisible = false;\n\nint least_divisor(int input) {\n\tint divisor = 2;\n\n\t// brute force integers from 2 - (input-1)\n\t// Logical or to evaluate corner case where divisor = input = 2, but \n\t// avoid evaluating other cases where input = divisor\n\twhile (divisor < input || input == 2) {\n\t\tif (input % divisor == 0) {\n\t\t\tdivisible = true;\n\t\t\treturn divisor;\n\t\t} else {\n\t\t\tdivisor++;\n\t\t}\n\t}\n\treturn 1;\n}\n\nint main(int argc, char ** argv) {\n\tcout << "Enter an integer: ";\n\t\n\tint input;\n\tcin >> input;\n\t\n\tint result = least_divisor(input);\n\n\t// if no divisor greater than 1 exists, the number must be prime \n\tif (result != 1) {\n\t\tcout << "This number is divisible by " << result << \'\\n\';\n\t} else {\n\t\tcout << "This number is undetermined\\n";\n\t}\n\n\treturn 0;\n}\n'}, {'name': 'Lab5C.cpp', 'language': 'C++', 'contents': '/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring \'23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nLab#: 5C\n*/\n\n#include <iostream>\nusing namespace std;\n\nint main(int argc, char ** argv) {\n\t// we define quadrant = 0 as the origin, quadrant = 5 as the x-axis \n\t// case, and quadrant = 6 as the y-axis case\n\tint x, y, quadrant;\n\tcout << "Enter x: ";\n\tcin >> x;\n\tcout << "Enter y: ";\n\tcin >> y;\n\n\tif (x == 0) {\n\t\t// if (0, nonzero): y-axis, else if (0,0): origin\n\t\tquadrant = (y != 0? 6:0);\n\t} else if (y == 0) {\n\t\t// if previous case did not execute, and y = 0, point lies on x\n\t\t// axis\n\t\tquadrant = 5;\n\t} else if (x > 0) {\n\t\t// if (+x,+y), point lies in quadrant 1. else if (+x, -y), point\n\t\t// lies in quadrant 4\n\t\tquadrant = (y > 0? 1:4);\n\t} else if (x < 0) {\n\t\t// if (-x, +y), point lies in quadrant 2, else if (-x, -y), point\n\t\t// lies in quadrant 3\n\t\tquadrant = (y > 0? 2: 3);\n\t}\n\n\tswitch (quadrant) {\n\t\tcase 0: \n\t\t\tcout << "This point is the origin.\\n";\n\t\t\tbreak;\n\t\tcase 1: \n\t\t\tcout << "This point is in the first quadrant.\\n";\n\t\t\tbreak;\n\t\tcase 2: \n\t\t\tcout << "This point is in the second quadrant.\\n";\n\t\t\tbreak;\n\t\tcase 3: \n\t\t\tcout << "This point is in the third quadrant.\\n";\n\t\t\tbreak;\n\t\tcase 4: \n\t\t\tcout << "This point is in the fourth quadrant.\\n";\n\t\t\tbreak;\n\t\tcase 5: \n\t\t\tcout << "This point is on the x axis.";\n\t\t\tbreak;\n\t\tcase 6: \n\t\t\tcout << "This point is on the y axis.";\n\t\t\tbreak;\n\t}\n\n\treturn 0;\n}\n'}, {'name': 'lab5C.cpp', 'language': None, 'contents': ''}, {'name': 'Lab6A.cpp', 'language': 'C++', 'contents': '/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring \'23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nLab#: 6A: Largest of 10\n*/\n#include <iostream>\nusing namespace std;\n\nint main(int argc, char ** argv) {\n\tcout << "Please enter 10 numbers and this program will display the largest." << endl << endl;\n\tint max = 0;\n\n\tfor (int index = 1; index <= 10; index++) {\n\t\tcout << "Please enter number " << index << ": ";\n\t\tint response;\n\t\tcin >> response;\n\t\tif (response > max) {\n\t\t\tmax = response;\n\t\t}\n\t}\n\n\tcout << "\\nThe largest number was " << max << \'\\n\';\n\n\treturn 0;\n}\n'}, {'name': 'Lab6B.cpp', 'language': 'C++', 'contents': '/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring \'23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nLab#: 6B: Pick a number between 1 and 1000\n*/\n\n#include <iostream>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n\nint main(int argc, char ** argv) {\n\tcout << "Enter a number between 1 and 1000: ";\n\tcout << endl;\n\tint response, guess;\n\tcin >> response;\n\tint attempts = 0;\n\tsrand((unsigned)time(0));\n\n\t// super inefficient implementation, to optimize for time I\'d push my guesses to a hashmap to check for duplicate guesses\n\twhile (response > 0 && response <=1000) {\n\t\tguess = (rand() % 1000);\n\t\tcout << "My guess was " << guess << endl;\n\t\tattempts++;\n\t\tif (guess == response) {\n\t\t\tcout << "\\nI guessed the number was " << guess << " and it only took me "  << attempts << " guesses\\n";\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n'}, {'name': 'Lab6C.cpp', 'language': 'C++', 'contents': '/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring \'23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nLab#: 6C: Cha-Ching\n*/\n\n#include <iostream>\nusing namespace std;\n\nint main(int argc, char ** argv) {\n\tint balance = 1000;\n\tcout << "Welcome!\\nYou have $" << balance << " in your account.\\n";\n\n\tchar sentinel = \'Y\';\n\twhile (sentinel == \'Y\' || sentinel == \'y\' ) {\n\t\tcout << "\\nMenu\\n" << "0 - Make a deposit\\n" << "1 - Make a withdrawal\\n" << "2 - Display account value\\n";\n\t\tcout << "\\nPlease make a selection: ";\n\t\tint selection;\n\t\tcin >> selection;\n\t\tswitch (selection) {\n\t\t\tcase 0: {\n\t\t\t\tcout << "How much would you like to deposit? : ";\n\t\t\t\tint deposit;\n\t\t\t\tcin >> deposit;\n\t\t\t\tbalance += deposit;\n\t\t\t\tcout << "Your current balance is $" << balance << \'\\n\';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 1: {\n\t\t\t\tcout << "How much would you like to withdraw? : ";\n\t\t\t\tint withdrawal;\n\t\t\t\tcin >> withdrawal;\n\t\t\t\tbalance -= withdrawal;\n\t\t\t\tcout << "Your current balance is $" << balance << \'\\n\';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 2: {\n\t\t\t\tcout << "Your current balance is $" << balance << \'\\n\';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tcout << "Invalid Entry, please try again.\\n";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tcout << "Would you like to return to the main menu (Y/N)? : ";\n\t\tcin >> sentinel;\n\t}\n\n\tcout << "\\nThank you for banking with us!\\n";\n\n\treturn 0;\n}\n'}, {'name': 'Lab7A.cpp', 'language': 'C++', 'contents': '/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring \'23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nLab#: 7A\n*/\n\n#include <iostream>\nusing namespace std;\n\nint main(int argc, char ** argv) {\n\tint dim;\n\tcout << "Please enter a value for the size: ";\n\tcin >> dim;\n\n\tcout << "This is the requested " << dim << \'x\' << dim << " box:\\n";\n\tfor (int outer = 0; outer < dim; outer++) {\n\t\tfor (int inner = 0; inner < dim; inner++) {\n\t\t\tcout << \'*\';\n\t\t}\n\t\tcout << \'\\n\';\n\t}\n\n\treturn 0;\n}\n'}, {'name': 'Lab7B.cpp', 'language': 'C++', 'contents': '/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring \'23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nLab#: 7B: Right-Triangle\n*/\n\n#include <iostream>\nusing namespace std;\n\nint main(int argc, char ** argv) {\n\tint dim;\n\tcout << "Please enter a value for the size: ";\n\tcin >> dim;\n\n\tcout << "This is the requested " << dim << \'x\' << dim << " right-triangle:\\n";\n\tfor (int outer = 0; outer < dim; outer++) {\n\t\tfor (int inner = 0; inner <= outer; inner++) {\n\t\t\tcout << \'*\';\n\t\t}\n\t\tcout << \'\\n\';\n\t}\n\n\treturn 0;\n}\n'}, {'name': 'Lab7C.cpp', 'language': 'C++', 'contents': '/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring \'23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nLab#: 7C: Right-Triangle (Left)\n*/\n\n#include <iostream>\nusing namespace std;\n\nint main(int argc, char ** argv) {\n\tint dim;\n\tcout << "Please enter a value for the size: ";\n\tcin >> dim;\n\n\tcout << "This is the requested " << dim << \'x\' << dim << " right-triangle:\\n";\n\tfor (int outer = 1; outer <= dim; outer++) {\n\t\tfor (int difference = dim; difference > outer; difference--) {\n\t\t\tcout << \' \';\n\t\t}\n\t\tfor (int inner = 1; inner <= outer; inner++) {\n\t\t\tcout << \'*\';\n\t\t}\n\t\tcout << \'\\n\';\n\t}\n\n\treturn 0;\n}\n'}, {'name': 'Lab8A.cpp', 'language': 'C++', 'contents': '/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring \'23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nLab#: 8A\n*/\n\n#include <iostream>\n\nusing namespace std;\n\nint main(int argc, char ** argv) {\n\tint arr1[5], arr2[5];\n\t// array 1 initialization\n\tcout << "Please enter 5 integers for the first array: \\n";\n\tfor (int i = 0; i < 5; i++) {\n\t\tcout << "Integer " << i + 1 << ": ";\n\t\tcin >> arr1[i];\n\t}\n\t// array 2 initialization\n\tcout << "\\nPlease enter 5 integers for the second array: \\n";\n\tfor (int i = 0; i < 5; i++) {\n\t\tcout << "Integer " << i + 1 << ": ";\n\t\tcin >> arr2[i];\n\t}\n\t\n\t// summation\n\tcout << "\\nThe resulting sums are ";\n\tfor (int i = 0; i < 5; i++) {\n\t\tcout << arr1[i] + arr2[i] << \'|\';\n\t}\n\tcout << \'\\n\';\n\n\treturn 0;\n}\n'}, {'name': 'Lab8B.cpp', 'language': 'C++', 'contents': '/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring \'23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nLab#: 8B: N by N\n*/\n\n#include <iostream>\nusing namespace std;\n\nint main(int argc, char ** argv) {\n\tint rows, cols;\n\tcout << "Please enter the number of rows: ";\n\tcin >> rows;\n\tcout << "Please enter the number of columns: ";\n\tcin >> cols;\n\n\tcout << "\\nI have " << rows << " rows and " << cols << " columns. I need"\n\t\t<< " to fill-up " << rows*cols << "spaces.\\n";\n\n\tcout << "\\nThe " << rows << \'x\' << cols << " array:\\n";\n\n\tint fill = 0;\n\tfor (int i = 0; i < rows; i++) {\n\t\tfor (int j = 0; j < cols; j++) {\n\t\t\tcout << ++fill << \'|\';\n\t\t}\t\n\t\tcout << \'\\n\';\n\t}\n\n\treturn 0;\n}\n'}, {'name': 'Lab8C.cpp', 'language': 'C++', 'contents': '/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring \'23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nLab#: 8C: 2D or not 2D\n*/\n\n#include <iostream>\nusing namespace std;\n\nint main(int argc, char ** argv) {\n\tint rows, cols;\n\tcout << "Please enter the number of rows: ";\n\tcin >> rows;\n\tcout << "Please enter the number of columns: ";\n\tcin >> cols;\n\n\tcout << "\\nI have " << rows << " rows and " << cols << " columns. I need"\n\t\t<< " to fill-up " << rows*cols << " spaces.\\n";\n\n\tcout << "\\nThe " << rows << \'x\' << cols << " array:\\n";\n\n\tint fill = 0;\n\tfor (int i = 0; i < rows; i++) {\n\t\tfor (int j = 0; j < cols; j++) {\n\t\t\tcout << ++fill << \'|\';\n\t\t}\t\n\t\tcout << \'\\n\';\n\t}\n\n\tcout << "\\nThe " << rows << \'x\' << cols << " 2-D array flattened into a " \n\t\t<< rows*cols << " cell 1-D array: \\n";\n\n\tint fill2 = 0;\n\tfor (int i = 0; i < rows; i++) {\n\t\tfor (int j = 0; j < cols; j++) {\n\t\t\tcout << ++fill2 << \'|\';\n\t\t}\t\n\t}\n\n\tcout << \'\\n\';\n\n\treturn 0;\n}\n'}, {'name': 'Lab9A.cpp', 'language': 'C++', 'contents': '/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring \'23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nLab#: 9A\n*/\n\n#include <iostream>\nusing namespace std;\n\nint main(int argc, char ** argv) {\n\tint nums[10] = {};\n\tcout << "Please enter 10 numbers: \\n";\n\tfor (int i=1; i <= 10; i++) {\n\t\tcout << "Integer " << i << ": ";\n\t\tcin >> nums[i-1];\n\t}\n\tint target;\n\tcout << "\\nWhat is the target number: ";\n\tcin >> target;\n\n\tbool found = false;\n\tfor (int i=0; i<10; i++) {\n\t\tif (nums[i] == target) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found) {\n\t\tcout << "\\nThe target is in the set.\\n";\n\t} else {\n\t\tcout << "\\nThe target is not in the set.\\n";\n\t}\n\n\treturn 0;\n}\n'}, {'name': 'Lab9B.cpp', 'language': 'C++', 'contents': '/* \nClass: CSE 1321L\nSection: WE1\nTerm: Spring \'23\nInstructor: Nick Murphy\nName: Nicholi Moore Caron\nLab#: 9A\n*/\n#include <iostream>\nusing namespace std;\n\nint main(int argc, char ** argv) {\n\tint nums[11] = {};\n\tcout << "Please enter 11 numbers: \\n";\n\tfor (int i=1; i <= 11; i++) {\n\t\tcout << "Integer " << i << ": ";\n\t\tcin >> nums[i-1];\n\t}\n\tint target;\n\tcout << "\\nWhat is the target number: ";\n\tcin >> target;\n\n\tfor (int i=0; i < 10; i++) {\n\t\tfor (int j=0; j < 10-i; j++) {\n\t\t\tif (nums[j] > nums[j+1]) {\n\t\t\t\tswap(nums[j], nums[j+1]);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << "The sorted set is: ";\n\tfor (int i=0; i < 11; i++) {\n\t\tcout << nums[i] << \' \';\n\t}\n\n\tbool found = false;\n\tint low = 0;\n\tint mid;\n\tint high = 10;\n\tdo {\n\t\tmid = (high+low)/2;\n\t\tcout << "\\nLow is " << low << \'\\n\';\n\t\tcout << "\\nHigh is " << high << \'\\n\';\n\t\tcout << "\\nMid is " << mid << \'\\n\';\n\t\tcout << "\\nSearching\\n";\n\t\tif (nums[mid] == target) {\n\t\t\tfound = true;\n\t\t} else if (nums[mid] > target) {\n\t\t\thigh = mid - 1;\n\t\t} else {\n\t\t\tlow = mid + 1;\n\t\t}\n\t} \n\twhile (low < high);\n\t// weird autograder quirk:\n\tcout << "\\nLow is " << low << \'\\n\';\n\tcout << "\\nHigh is " << high << \'\\n\';\n\tcout << "\\nMid is " << mid + 1 << \'\\n\';\n\tcout << "\\nSearching\\n";\n\tif (nums[high] == target) {\n\t\tfound = true;\n\t}\n\n\tif (found) {\n\t\tcout << "\\nThe target is in the set.\\n";\n\t} else {\n\t\tcout << "\\nThe target is not in the set.\\n";\n\t}\n\n\treturn 0;\n}\n'}], 'primaryLanguage': 'C++', 'stars': 0, 'readme': None}, {'name': 'NeekOS', 'files': [], 'primaryLanguage': None, 'stars': 0, 'readme': "# NeekOS\nThis project is my attempt to learn about Operating Systems by implementing one. As far as the name, my nickname is Neeko, so I figured the name is only right\n- The initial code will draw heavily from Phil Opperman's blog series on the subject (https://os.phil-opp.com/). \n- Inspiration for how to expand from there will come from:\n  - MIT's Caffeinated 6.828 (https://sipb.mit.edu/iap/6.828/),\n  - and Georgia Tech's CS-3210 (https://tc.gtisc.gatech.edu/cs3210/2020/spring/info.html)\n\nI will create a binary that will run on my Raspberry Pi 3B+, and will have at least the following features:\n  - Shell\n  - Bootloader\n  - FAT32 Filesystem\n  - Multitasking and Locking\n  - Scalable TCP/IP\n\n- Some further objectives include: \n  -  Implementing Address Space Layout Randomization\n  -  Tracing memory allocations and deallocations\n  -  Handling OOM (Out of Memory)\n  -  Fuzzing NeekOS's interfaces/file systems\n  -  Abstractions for Linux Device Drivers\n  -  Linux Scheduling Policies\n  -  Non-blocking synchronization (sleepable mutex)\n\nAccompanying blog post coming soon\n"}, {'name': 'Minecroft', 'files': [], 'primaryLanguage': 'Jupyter Notebook', 'stars': 0, 'readme': None}, {'name': 'JustKnowStuff', 'files': [], 'primaryLanguage': 'Jupyter Notebook', 'stars': 0, 'readme': '# JustKnowStuff\n\nTaking a page out of Patrick Kidger\'s blog and blogging about topics included in (https://kidger.site/thoughts/just-know-stuff/). Implementations and links will be placed here. \n\n## Table of Contents ##\n- What are the necessary elements of Deep Learning?\n  + https://github.com/nicholicaron/JustKnowStuff/tree/main/dl_sys\n- Know both forward- and reverse-mode autodifferentiation\n  + https://www.nicholi.me/autodiff\n- What is Strassen\'s Algorithm? How are matrix multiplies actually done in practice? Write your own implementation of multihead attention\n  + https://www.nicholi.me/take-heed-of-the-hydra/\n- What are Winograd Convolutions? Write your own implementation of a convolutional layer\n  + https://www.nicholi.me/convolutions/\n- Know the universal approximation theorem\n- Learn the basics of Graph Neural Networks (E.g. what is oversmoothing?) How do these generalize CNNs?\n- Learn modern Transformer architectures. Build a toy implementation.\n- Learn U-Nets. Build a toy implementation.\n- Know how residual networks are discretized ordinary differential equations\n- Know how Gated Recurrent Units (GRUs) are also discretized differential equations\n- Know how stochastic gradient descent is also a discretized differential equation too! (Yes, including the "stochastic": that\'s a Monte-Carlo discretization of an expectation.) These are gradient flows\n- Know what is meant by the manifold hypothesis\n- Learn the basics of policy gradients. Implement PPO to solve cart-pole.\n- Learn KL divergence, Wasserstein distance, MMD distance\n- Learn normalizing flows, VAEs, WGANs, score-based diffusion models. Implement a basic score-based diffusion from scratch\n- Try the basics of distributes training of a model. (Over multiple GPUs; multiple computers)\n- Know how to do hyperparameter optimization via Bayesian optimization. [Optional: Try doing this in a distributed fashion, with a main thread sending hyperparameter jobs to different machines, and receiving results back]\n- Learn the formulae for Adadelta, Adam, etc. What were the innovations for each optimizer? (Momentum, second moments, ...) What are some of the newer ones that are now being used (Adabelief, RAdam, NAdamW, etc. -- this is a flavor of the month kinda field)\n- Learn why we use first-order optimization techniques (SGD and friends) rather than anything else. (Why not Gauss-Newton? Why not Newton-Raphson? Why not Levenberg-Marquardt?) \n'}, {'name': '2023-Fall-Hackathon', 'files': [{'name': 'classes.py', 'language': 'Python', 'contents': 'from bs4 import BeautifulSoup\nimport requests\nimport re\nimport json\n\ndef soupify(url:str) -> BeautifulSoup:\n    \n    headers = {\'User-Agent\': \'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:99.0) Gecko/20100101 Firefox/99.0\'}\n    temp_page = requests.get(url, headers=headers)\n    return BeautifulSoup(temp_page.text,features=\'html.parser\')\n\ndef main() -> dict:\n    #32 pages of classes, at the time of making this\n    courses = {}\n    for page in range(1,32):\n        \n        url = "https://catalog.kennesaw.edu/content.php?catoid=68&catoid=68&navoid=5469&filter%5Bitem_type%5D=3&filter%5Bonly_active%5D=1&filter%5B3%5D=1&filter%5Bcpage%5D={0}#acalog_template_course_filter".format(page)\n\n        page = soupify(url).find_all(class_="block_content")\n        for p in page:\n            #Key is always re-set first thing on each page so I clear it just to be safe.\n            key = ""\n            print(len(p.find_all("table")))\n\n            for i in [3,2,1]:\n                try:\n                    course_list = p.find_all("table")[i]\n                    \n                    #Usually table 3 is the search box, so looking for this chunk of text makes sure we skip that.\n                    if "Filter this list of courses" in course_list.text:\n                        continue\n\n                except IndexError as e:\n                    if i == 1:\n                        print(f"Couldn\'t find a proper main body tag on page {page}")\n                        return\n\n            #Finding all table rows and chopping off some blank ones\n            tr_list = course_list.find_all("tr")[1:]\n            tr_list = tr_list[:len(tr_list)-1]\n\n            for row in tr_list:\n                #Course Categories are only marked by a strong tag, so this makes them the key for the dict\n                if len(row.find_all("strong")) > 0:\n\n                    key = re.sub(r\'[^A-Za-z0-9 /\\\':()-]\', \'\', row.text)\n                    courses[key] = []\n\n                #Had some issues with the nav bar at the bottom, checking for a colon fixed it, but it could be skipping courses. Not sure.\n                elif ":" in row.text:\n\n                    txt = re.sub(r\'[^A-Za-z0-9 /\\\':()-]\', \'\', row.text).split(":")\n                    courses[key].append((txt[0],txt[1]))\n\n    return courses\n\n\n            \n\nif __name__ == "__main__":\n    #Creates a json file using class category as the keys for a list of class entries\n    #Each entry is a tuple, containing class number (ex: ACCT 2101) as the first entry, and the class name (ex: Internal Auditing) as the second entry.\n    classes = main()\n    with open("classes.json", "w") as f:\n        json.dump(classes, f, indent=4)\n'}, {'name': 'degrees.py', 'language': 'Python', 'contents': 'from bs4 import BeautifulSoup\nfrom lxml import etree\nimport requests\nimport re\nimport json\nfrom os import path\n\n#https://stackoverflow.com/questions/46419607/how-to-automatically-install-required-packages-from-a-python-script-as-necessary\n\nclass DegreePage:\n\n    def __init__(self, title:str | None = "", description:str | None = None, careers:str | None = None, school:str | None = None):\n        #intentionally not using salary, cant really quantify how important money is to someone\n        self.title = title\n        self.description = description\n        self.careers = careers\n        self.school = school\n    \n    def __str__(self):\n        return self.title\n\n#End DegreePage\n\n#Takes a url, spits back a BS4 object.\ndef soupify(url:str) -> BeautifulSoup:\n    \n    headers = {\'User-Agent\': \'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:99.0) Gecko/20100101 Firefox/99.0\'}\n    temp_page = requests.get(url, headers=headers, timeout=3)\n    return BeautifulSoup(temp_page.text,features=\'html.parser\')\n\n#This nabs all the links within a given BeautifulSoup object and returns them in a list\n#Only checks for a tags\ndef get_links(soup:BeautifulSoup) -> list:\n    a_tags = soup.find_all("a")\n    links = []\n    for a in a_tags:\n\n        if a.has_attr(\'href\'):\n            links.append(a[\'href\'])\n\n    return links\n\n#End get_links\n\n#Takes in a degree page as a bs4 object and packages up the info into a dict\ndef package_page_info(soup:BeautifulSoup) -> DegreePage:\n    page = DegreePage()\n    page.title = re.sub(r\'[^A-Za-z0-9\\\'/() ]\', \'\',soup.find(class_="banner_message").text)\n    print("Degree title detected as {}".format(page.title))\n    while page.description == "" or page.description == None:\n        page.description = input("Enter a brief description of the course: ")\n    \n    #Makes it so you can skip json files you\'ve already made.\n    if page.description == "skip":\n        return page\n\n    while page.careers == "" or page.careers == None:\n        page.careers = input("Enter a few possible careers listed: ")\n\n    while page.school == "" or page.school == None:\n        page.school = input("Enter the school/department: ")\n\n    return page\n    \n#End package_page_info\n\n#Writes a json file given a dictionary\n#If overwrite is set to true, it will not check if the file exists first.\ndef write_json(filename:str, data:dict, overwrite=False, indent=4) -> None:\n    if not overwrite and path.isfile(filename):\n        return\n\n    with open(filename, "w") as f:\n        json.dump(data, f, indent=indent)\n\n#End write_json\n\n#Function that is run when the script is executed\n#At the moment, it runs through the list of degrees and prompts the user to enter them all.\n#Cant be run from inside of vim because of the input() funcs\ndef main() -> None:\n    b_soup = soupify("https://www.kennesaw.edu/degrees-programs/bachelor-degrees/index.php").find(class_="searchable_list")\n    m_soup = soupify("https://www.kennesaw.edu/degrees-programs/master-degrees/index.php").find(class_="searchable_list")\n    \n    b_links = get_links(b_soup)\n    m_links = get_links(m_soup)\n    \n    #=============Bachelors Degree Pages===========\n    for link in b_links:\n        t_soup = soupify(link)\n        page = package_page_info(t_soup)\n        json_name = "json/{}.json".format(str(page))\n        if path.isfile(json_name):\n            continue\n\n        write_json(json_name, page.__dict__)\n\n    #==============Masters Degree Pages=============\n    for link in m_links:\n        t_soup = soupify(link)\n        page = package_page_info(t_soup)\n        json_name = "json/{}.json".format(str(page))\n        if path.isfile(json_name):\n            continue\n\n        write_json(json_name, page.__dict__)\n    \n#End main\n\nif __name__ == "__main__":\n    main()'}, {'name': 'main.py', 'language': 'Python', 'contents': 'import discord\nimport asyncio\nfrom discord.ext import commands\nfrom configparser import ConfigParser\nfrom tree import traverse\ncfg = ConfigParser()\n\n# To run tree just call traverse()\n\n#Somehow this works on windows? Not sure if configparser is just that good or something else is going on\n#Def need to test this before deploying\ncfg.read(\'secret.ini\')\nTOKEN = cfg[\'DEFAULT\'][\'TOKEN\']\n\n#This makes the bot able to read messages\nintents = discord.Intents.default()\nintents.message_content = True\n\nclient = commands.Bot(command_prefix=\'!\', intents=intents)\n\n@client.command()\nasync def test(ctx):\n    #User types !test, bot prints the context dict out to the console\n    print(ctx.__dict__)\n\n#Example quiz command I put together because I couldnt sleep - DJ\n#arg unused for now, could use it to show past results/answers?\n@client.command()\nasync def quiz(ctx, arg):\n    root_node = build_tree()\n    active_node = root_node\n    await ctx.reply(f\'Hello {ctx.author.name}. Beginning Quiz!\')\n    await asyncio.sleep(1)\n\n    #active node\'s data is the current question being asked\n    msg = ""\n    #Forces user to type 1 or 2, there are more elegant ways of doing this, like reaction monitoring.\n    while msg != "1" and msg != "2":\n        await ctx.reply(f\'{active_node.data}\')\n        msg = await client.wait_for(\'message\', check=check(ctx.author), timeout=30)\n        #blahblahblah\n\n#Checks if author of message is the author of the original message too\ndef check(author):\n    def inner_check(message):\n        if message.author != author:\n            return False\n        \n        return True\n    return inner_check\n#Starts the bot.\nclient.run(TOKEN)\n'}, {'name': 'tree.py', 'language': 'Python', 'contents': '# Prototyping\n#\n# This code is really rough around the edges and could definitely benefit from refactoring\n# But first, we have to try to get something that works\n#\nq1 = "What was your favorite subject in high school? (math, science, literature, history, art):  "\nq2 = "How do you derive meaning in your life? (through work, family and friends):  "\nq3 = "Do you prefer to work with people or by yourself? (with people, solo):  "\nq4_1 = "Would you like to work in education? (yes, no):  "\nq4_2 = "Would you rather be wealthy or respected by your peers? (wealthy, respected):  "\nq5_1 = "Which age group? (elementary, middle, high, college):  "\nq5_2 = "Do you like computers? (yes, no):  "\nq5_3 = "Would you like to explore cultures or people in general? (cultures, general):  "\n\nlevel = 1\next_flag = False\nedu_flag = False\nmath_flag = False\nlit_flag = False\nlit_woke_flag = False\nhist_flag = False\n\n\nclass TreeNode:\n    def __init__(self, question:str):\n        self.question = question\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def get_child(self, index):\n        if index < len(self.children):\n            return self.children[index]\n        \n        return None\n    \ndef print_tree(node:TreeNode, level=0):\n    print(" " * level + str(node.question))\n    for child in node.children:\n        print_tree(child, level + 1)\n\ndef conditional_traversal(node:TreeNode):\n    global level\n    global ext_flag\n    global edu_flag\n    global math_flag\n    global lit_flag\n    global lit_woke_flag\n    global hist_flag\n    #Could maybe make all of these attributes of the tree? Might help if we want users to be able to save trees in the future -DJ\n\n\n    user_input = input(node.question)\n    # Requires Python > 3.10\n    match level:\n        case 1: \n            match user_input: \n                case "math":\n                    math_flag = True\n                    # There\'s probably a more readable way to do this but for MVP sake:\n                    level += 1\n                    conditional_traversal(node.get_child(0))\n                    #Yeah, recursion feels like we\'ll run into memory issues down the road.\n                    #I went ahead and encapsulated get child into the node class to make that a bit cleaner at least -DJ\n\n                case "science":\n                    level += 1\n                    conditional_traversal(node.get_child(1))\n\n                case "literature":\n                    level += 1\n                    conditional_traversal(node.get_child(2))\n                    \n                case "history":\n                    hist_flag = True\n                    level += 1\n                    conditional_traversal(node.get_child(3))\n\n                case "art":\n                    level += 1\n                    conditional_traversal(node.get_child(4))\n\n                case _ :\n                    print("Unable to read user input")\n        case 2: \n            match user_input: \n                case "through work":\n                    level += 1\n                    conditional_traversal(node.get_child(0))\n\n                case "family and friends":\n                    level += 1\n                    conditional_traversal(node.get_child(1))\n\n                case _:\n                    print("Unable to read user input")\n\n        case 3: \n            match user_input:\n                case "with people":\n                    ext_flag = True\n                    level += 1\n                    conditional_traversal(node.get_child(0))\n\n                case "solo":\n                    level += 1\n                    conditional_traversal(node.get_child(1))\n\n                case _:\n                    print("Unable to read user input")\n        case 4: \n            if ext_flag: # Education\n                match user_input:\n                    case "yes":\n                        edu_flag = True\n                        level += 1\n                        conditional_traversal(node.get_child(0))\n\n                    case "no":\n                        if lit_flag:\n                            level += 1\n                            conditional_traversal(node.get_child(1))\n                        else:\n                            print(f"Your major should be: {node.get_child(1).question}")\n\n                    case _:\n                        print("Unable to read user input")\n            else:\n                match user_input: # Respect or money\n                    case "wealthy":\n                        if math_flag:\n                            conditional_traversal(node.get_child(0))\n                        else:\n                            print(f"Your major should be: {node.get_child(0).question}")\n\n                    case "respected":\n                        if lit_flag:\n                            level += 1\n                            conditional_traversal(node.get_child(1))\n                        else:\n                            print(f"Your major should be: {node.get_child(1).question}")\n\n                    case _:\n                        print("Unable to read user input")\n        case 5:\n            if edu_flag: # age group\n                match user_input:\n                    case "elementary":\n                        print(f"Your major should be: {node.get_child(0).question}")\n                        return\n\n                    case "middle":\n                        print(f"Your major should be: {node.get_child(1).question}")\n                        return\n\n                    case "high":\n                        print(f"Your major should be: {node.get_child(2).question}")\n                        return\n\n                    case "college":\n                        print(f"Your major should be: {node.get_child(3).question}")\n                        return\n\n                    case _:\n                        print("Unable to read user input")\n            elif (not edu_flag) and math_flag: # Introverted math person interested in computers? \n                match user_input:\n                    case "yes":\n                        print(f"Your major should be: {node.get_child(0).question}")\n                        return\n\n                    case "no":\n                        print(f"Your major should be: {node.get_child(1).question}")\n                        return\n\n                    case _:\n                        print("Unable to read user input")\n            else:\n                match user_input: # In one of lit\'s longest paths\n                    case "wealthy":\n                        print(f"Your major should be:{node.get_child(0).question}")\n                        return\n                    case "respected":\n                        if lit_woke_flag:\n                            level += 1\n                            conditional_traversal(node.get_child(1))\n                        else: \n                            print(f"Your major should be: {node.get_child(1).question}")\n                            return\n\n                    case _:\n                        print("Unable to read user input")\n        case 7:\n            match user_input: # Still in lit\'s longest path\n                case "cultures":\n                    print(f"Your major should be:{node.get_child(0).question}")\n                    return\n\n                case "general":\n                    print(f"Your major should be:{node.get_child(1).question}")\n                    return\n\n                case _:\n                    print("Unable to read user input")\n        case _:\n            print("Some unknown error has occurred. Try again")\n\ndef traverse(root:TreeNode) -> None:\n    print("Hi there, I\'m Scruffy! I\'m going to ask you a few questions to help you narrow down your major.")\n    print("Please try to remember to enter all your answers in lowercase.")\n    print("Let\'s go!")\n    print(" ")\n    conditional_traversal(root)\n\n# Define Tree\n#\n# I could make this much less verbose but for readibility sake, I\'ll leave the\n# variable instantiations\n#\n\n#Encapsulated so we can just import file in other py files -DJ\ndef build_tree() -> TreeNode:\n    # First Level\n    root = TreeNode(q1)\n\n    # Second Level\n    math = TreeNode(q2)\n    sci = TreeNode(q2)\n    lit = TreeNode(q2)\n    hist = TreeNode(q2)\n    art = TreeNode(q2)\n\n    root.add_child(math)\n    root.add_child(sci)\n    root.add_child(lit)\n    root.add_child(hist)\n    root.add_child(art)\n\n    # Third Level\n    math_work = TreeNode(q3)\n    sci_work = TreeNode(q3)\n    lit_work = TreeNode(q3)\n    hist_work = TreeNode(q3)\n    art_work = TreeNode(q3)\n\n    math_fam = TreeNode(q3)\n    sci_fam = TreeNode(q3)\n    lit_fam = TreeNode(q3)\n    hist_fam = TreeNode(q3)\n    art_fam = TreeNode(q3)\n\n    math.add_child(math_work)\n    math.add_child(math_fam)\n    sci.add_child(sci_work)\n    sci.add_child(sci_fam)\n    lit.add_child(lit_work)\n    lit.add_child(lit_fam)\n    hist.add_child(hist_work)\n    hist.add_child(hist_fam)\n    art.add_child(art_work)\n    art.add_child(art_fam)\n\n    # Fourth Level\n    math_work_ext = TreeNode(q4_1)\n    sci_work_ext = TreeNode(q4_1)\n    lit_work_ext = TreeNode(q4_1)\n    hist_work_ext = TreeNode(q4_1)\n    art_work_ext = TreeNode(q4_1)\n\n    math_work_int = TreeNode(q4_2)\n    sci_work_int = TreeNode(q4_2)\n    lit_work_int = TreeNode(q4_2)\n    hist_work_int = TreeNode(q4_2)\n    art_work_int = TreeNode(q4_2)\n\n    math_fam_ext = TreeNode(q4_1)\n    sci_fam_ext = TreeNode(q4_1)\n    lit_fam_ext = TreeNode(q4_1)\n    hist_fam_ext = TreeNode(q4_1)\n    art_fam_ext = TreeNode(q4_1)\n\n    math_fam_int = TreeNode(q4_2)\n    sci_fam_int = TreeNode(q4_2)\n    lit_fam_int = TreeNode(q4_2)\n    hist_fam_int = TreeNode(q4_2)\n    art_fam_int = TreeNode(q4_2)\n\n    math_work.add_child(math_work_ext)\n    math_work.add_child(math_work_int)\n    math_fam.add_child(math_fam_ext)\n    math_fam.add_child(math_fam_int)\n\n    sci_work.add_child(sci_work_ext)\n    sci_work.add_child(sci_work_int)\n    sci_fam.add_child(sci_fam_ext)\n    sci_fam.add_child(sci_fam_int)\n\n    lit_work.add_child(lit_work_ext)\n    lit_work.add_child(lit_work_int)\n    lit_fam.add_child(lit_fam_ext)\n    lit_fam.add_child(lit_fam_int)\n\n    hist_work.add_child(hist_work_ext)\n    hist_work.add_child(hist_work_ext)\n    hist_fam.add_child(hist_fam_int)\n    hist_fam.add_child(hist_fam_int)\n\n    art_work.add_child(art_work_ext)\n    art_work.add_child(art_work_ext)\n    art_fam.add_child(art_fam_int)\n    art_fam.add_child(art_fam_int)\n\n    # Fifth Level\n    math_work_ext_edu = TreeNode(q5_1)\n    sci_work_ext_edu = TreeNode(q5_1)\n    lit_work_ext_edu = TreeNode(q5_1)\n    hist_work_ext_edu = TreeNode(q5_1)\n    art_work_ext_edu = TreeNode(q5_1)\n\n    math_work_ext_noedu = TreeNode("Mathematics, Finance, Mechanical Engineering, or Computer Engineering")\n    sci_work_ext_noedu = TreeNode("Integrated Health Sciences, Biology, or Nursing")\n    lit_work_ext_noedu = TreeNode(q4_2)\n    hist_work_ext_noedu = TreeNode("International Affairs, Political Science, or Media and Entertainment")\n    art_work_ext_noedu = TreeNode("Media and Entertainment, Digital Animation, or Theatre and Performance Studies")\n\n    math_fam_ext_edu = TreeNode(q5_1)\n    sci_fam_ext_edu = TreeNode(q5_1)\n    lit_fam_ext_edu = TreeNode(q5_1)\n    hist_fam_ext_edu = TreeNode(q5_1)\n    art_fam_ext_edu = TreeNode(q5_1)\n\n    math_fam_ext_noedu = TreeNode("Electrical Engineering Technology")\n    sci_fam_ext_noedu = TreeNode("Public Health Education")\n    lit_fam_ext_noedu = TreeNode(q4_2)\n    hist_fam_ext_noedu = TreeNode("Human Services, or Theatre and Performance Studies")\n    art_fam_ext_noedu = TreeNode("Theatre and Performance Studies")\n\n    math_work_int_money = TreeNode(q5_2)\n    sci_work_int_money = TreeNode("Physics")\n    lit_work_int_money = TreeNode("Marketing, Hospitality, or Management")\n    hist_work_int_money = TreeNode("Management, Construction Management, or Entrepreneurship")\n    art_work_int_money = TreeNode("Architecture")\n\n    math_work_int_resp = TreeNode("Mathematics, Physics, Economics, or Accounting")\n    sci_work_int_resp = TreeNode("Biochemistry, Chemistry, Biology, or Physics")\n    lit_work_int_resp = TreeNode("English, Modern Language and Culture, Criminal Justice, or Journalism and Emerging Media")\n    hist_work_int_resp= TreeNode("Antrhopology")\n    art_work_int_resp = TreeNode("Textile and Surface Design")\n\n    math_fam_int_money = TreeNode("Data Science and Analytics")\n    sci_fam_int_money = TreeNode("Technical Communication")\n    lit_fam_int_money = TreeNode("Technical Communication")\n    hist_fam_int_money = TreeNode("International Affairs")\n    art_fam_int_money = TreeNode("Digital Animation")\n\n    math_fam_int_resp = TreeNode("Mathematics")\n    sci_fam_int_resp = TreeNode("Geospatial Science, or Environmental Engineering")\n    lit_fam_int_resp = TreeNode("English")\n    hist_fam_int_resp = TreeNode("Anthropology, Philosophy, or Geography")\n    art_fam_int_resp = TreeNode("Art, Textile and Surface Design, or Digital Animation")\n\n    math_work_ext.add_child(math_work_ext_edu)\n    math_work_ext.add_child(math_work_ext_noedu)\n    math_fam_ext.add_child(math_fam_ext_edu)\n    math_fam_ext.add_child(math_fam_ext_noedu)\n    math_work_int.add_child(math_work_int_money)\n    math_work_int.add_child(math_work_int_resp)\n    math_fam_int.add_child(math_fam_int_money)\n    math_fam_int.add_child(math_fam_int_money)\n\n    sci_work_ext.add_child(sci_work_ext_edu)\n    sci_work_ext.add_child(sci_work_ext_noedu)\n    sci_fam_ext.add_child(sci_fam_ext_edu)\n    sci_fam_ext.add_child(sci_fam_ext_noedu)\n    sci_work_int.add_child(sci_work_int_money)\n    sci_work_int.add_child(sci_work_int_resp)\n    sci_fam_int.add_child(sci_fam_int_money)\n    sci_fam_int.add_child(sci_fam_int_resp)\n\n    lit_work_ext.add_child(lit_work_ext_edu)\n    lit_work_ext.add_child(lit_work_ext_noedu)\n    lit_fam_ext.add_child(lit_fam_ext_edu)\n    lit_fam_ext.add_child(lit_fam_ext_noedu)\n    lit_work_int.add_child(lit_work_int_money)\n    lit_work_int.add_child(lit_work_int_resp)\n    lit_fam_int.add_child(lit_fam_int_money)\n    lit_fam_int.add_child(lit_fam_int_resp)\n\n    hist_work_ext.add_child(hist_work_ext_edu)\n    hist_work_ext.add_child(hist_work_ext_noedu)\n    hist_fam_ext.add_child(hist_fam_ext_edu)\n    hist_fam_ext.add_child(hist_fam_ext_noedu)\n    hist_work_int.add_child(hist_work_int_money)\n    hist_work_int.add_child(hist_work_int_resp)\n    hist_fam_int.add_child(hist_fam_int_money)\n    hist_fam_int.add_child(hist_fam_int_resp)\n\n    art_work_ext.add_child(art_work_ext_edu)\n    art_work_ext.add_child(art_work_ext_noedu)\n    art_fam_ext.add_child(art_fam_ext_edu)\n    art_fam_ext.add_child(art_fam_ext_noedu)\n    art_work_int.add_child(art_work_int_money)\n    art_work_int.add_child(art_work_int_resp)\n    art_fam_int.add_child(art_fam_int_money)\n    art_fam_int.add_child(art_fam_int_resp)\n\n\n    # Sixth Level\n    math_work_ext_edu_elem = TreeNode("Elementary Education")\n    sci_work_ext_edu_elem = TreeNode("Elementary Education")\n    lit_work_ext_edu_elem = TreeNode("Elementary Education or English Education")\n    hist_work_ext_edu_elem = TreeNode("Elementary Education or History Education")\n    art_work_ext_edu_elem = TreeNode("Elementary Education or Music Education")\n\n    math_work_ext_edu_mid = TreeNode("Middle Grades Education")\n    sci_work_ext_edu_mid = TreeNode("Middle Grades Education")\n    lit_work_ext_edu_mid = TreeNode("Middle Grades Education or English Education")\n    hist_work_ext_edu_mid = TreeNode("Middle Grades Education or History Education")\n    art_work_ext_edu_mid = TreeNode("Middle Grades Education or Music Education")\n\n    math_work_ext_edu_high = TreeNode("Secondary Education, Mathematics, or Physics")\n    sci_work_ext_edu_high = TreeNode("Secondary Education, Physics, Biology, or Chemistry")\n    lit_work_ext_edu_high = TreeNode("Secondary Education or English Education")\n    hist_work_ext_edu_high = TreeNode("Secondary Education or History Education")\n    art_work_ext_edu_high = TreeNode("Secondary Education or Music Education")\n\n    math_work_ext_edu_uni = TreeNode("Mathematics or Physics")\n    sci_work_ext_edu_uni = TreeNode("Physics, Chemistry, Biology, or Biochemistry")\n    lit_work_ext_edu_uni = TreeNode("English or English Education")\n    hist_work_ext_edu_uni = TreeNode("Geography, History or History Education")\n    art_work_ext_edu_uni = TreeNode("Art, Music, or Music Education")\n\n    math_fam_ext_edu_elem = TreeNode("Elementary Education")\n    sci_fam_ext_edu_elem = TreeNode("Elementary Education")\n    lit_fam_ext_edu_elem = TreeNode("Elementary Education or English Education")\n    hist_fam_ext_edu_elem = TreeNode("Elementary Education or History Education")\n    art_fam_ext_edu_elem = TreeNode("Elementary Education or Music Education")\n\n    math_fam_ext_edu_mid = TreeNode("Middle Grades Education")\n    sci_fam_ext_edu_mid = TreeNode("Middle Grades Education")\n    lit_fam_ext_edu_mid = TreeNode("Middle Grades Education or English Education")\n    hist_fam_ext_edu_mid = TreeNode("Middle Grades Education or History Education")\n    art_fam_ext_edu_mid = TreeNode("Middle Grades Education or Music Education")\n\n    math_fam_ext_edu_high = TreeNode("Secondary Education, Mathematics, or Physics")\n    sci_fam_ext_edu_high = TreeNode("Secondary Education, Physics, Biology, or Chemistry")\n    lit_fam_ext_edu_high = TreeNode("Secondary Education or English Education")\n    hist_fam_ext_edu_high = TreeNode("Secondary Education or History Education")\n    art_fam_ext_edu_high = TreeNode("Secondary Education or Music Education")\n\n    math_fam_ext_edu_uni = TreeNode("Mathematics or Physics")\n    sci_fam_ext_edu_uni = TreeNode("Physics, Chemistry, Biology, or Biochemistry")\n    lit_fam_ext_edu_uni = TreeNode("English or English Education")\n    hist_fam_ext_edu_uni = TreeNode("Geography, History or History Education")\n    art_fam_ext_edu_uni = TreeNode("Art, Music, or Music Education")\n\n    math_work_int_money_comp = TreeNode("Cybersecurity, Information Technology, Computer Science, Computer Engineering, Electrical Engineering, or Software Engineering")\n    math_work_int_money_nocomp = TreeNode("Mathematics, Physics")\n\n    lit_work_ext_noedu_money = TreeNode("Entrepreneurship, Management, Marketing, or Professional Sales")\n    lit_work_ext_noedu_resp = TreeNode("Organizational and Professional Communication, Marketing, Human Services, Criminal Justice, or Journalism and Emerging Media")\n    lit_fam_ext_noedu_money = TreeNode("Marketing or Psychology")\n    lit_fam_ext_noedu_resp = TreeNode(q5_3)\n\n    math_work_ext_edu.add_child(math_work_ext_edu_elem)\n    math_work_ext_edu.add_child(math_work_ext_edu_mid)\n    math_work_ext_edu.add_child(math_work_ext_edu_high)\n    math_work_ext_edu.add_child(math_work_ext_edu_uni)\n\n    math_fam_ext_edu.add_child(math_fam_ext_edu_elem)\n    math_fam_ext_edu.add_child(math_fam_ext_edu_mid)\n    math_fam_ext_edu.add_child(math_fam_ext_edu_high)\n    math_fam_ext_edu.add_child(math_fam_ext_edu_uni)\n\n    sci_work_ext_edu.add_child(sci_work_ext_edu_elem)\n    sci_work_ext_edu.add_child(sci_work_ext_edu_mid)\n    sci_work_ext_edu.add_child(sci_work_ext_edu_high)\n    sci_work_ext_edu.add_child(sci_work_ext_edu_uni)\n\n    sci_fam_ext_edu.add_child(sci_fam_ext_edu_elem)\n    sci_fam_ext_edu.add_child(sci_fam_ext_edu_mid)\n    sci_fam_ext_edu.add_child(sci_fam_ext_edu_high)\n    sci_fam_ext_edu.add_child(sci_fam_ext_edu_uni)\n\n    lit_work_ext_edu.add_child(lit_work_ext_edu_elem)\n    lit_work_ext_edu.add_child(lit_work_ext_edu_mid)\n    lit_work_ext_edu.add_child(lit_work_ext_edu_high)\n    lit_work_ext_edu.add_child(lit_work_ext_edu_uni)\n\n    lit_fam_ext_edu.add_child(lit_fam_ext_edu_elem)\n    lit_fam_ext_edu.add_child(lit_fam_ext_edu_mid)\n    lit_fam_ext_edu.add_child(lit_fam_ext_edu_high)\n    lit_fam_ext_edu.add_child(lit_fam_ext_edu_uni)\n\n    hist_work_ext_edu.add_child(hist_work_ext_edu_elem)\n    hist_work_ext_edu.add_child(hist_work_ext_edu_mid)\n    hist_work_ext_edu.add_child(hist_work_ext_edu_high)\n    hist_work_ext_edu.add_child(hist_work_ext_edu_uni)\n\n    hist_fam_ext_edu.add_child(hist_fam_ext_edu_elem)\n    hist_fam_ext_edu.add_child(hist_fam_ext_edu_mid)\n    hist_fam_ext_edu.add_child(hist_fam_ext_edu_high)\n    hist_fam_ext_edu.add_child(hist_fam_ext_edu_uni)\n\n    art_work_ext_edu.add_child(art_work_ext_edu_elem)\n    art_work_ext_edu.add_child(art_work_ext_edu_mid)\n    art_work_ext_edu.add_child(art_work_ext_edu_high)\n    art_work_ext_edu.add_child(art_work_ext_edu_uni)\n\n    art_fam_ext_edu.add_child(art_fam_ext_edu_elem)\n    art_fam_ext_edu.add_child(art_fam_ext_edu_mid)\n    art_fam_ext_edu.add_child(art_fam_ext_edu_high)\n    art_fam_ext_edu.add_child(art_fam_ext_edu_uni)\n\n    math_work_int_money.add_child(math_work_int_money_comp)\n    math_work_int_money.add_child(math_work_int_money_nocomp)\n\n    lit_work_ext_noedu.add_child(lit_work_ext_noedu_money)\n    lit_work_ext_noedu.add_child(lit_work_ext_noedu_resp)\n    lit_fam_ext_noedu.add_child(lit_fam_ext_noedu_money)\n    lit_fam_ext_noedu.add_child(lit_fam_ext_noedu_resp)\n\n\n    # Seventh Level\n    lit_fam_ext_noedu_resp_gen = TreeNode("Psychology, Sociology, Exercise Science, or Health and Physical Activities Leadership")\n    lit_fam_ext_noedu_resp_cult = TreeNode("Asian Studies, Black Studies, or Modern Language and Culture")\n\n    lit_fam_ext_noedu_resp.add_child(lit_fam_ext_noedu_resp_gen)\n    lit_fam_ext_noedu_resp.add_child(lit_fam_ext_noedu_resp_cult)\n\n    return root\n\n\nif __name__ == "__main__":\n    #Makes tree and runs test interaction program\n    root = build_tree()\n    traverse(root)'}], 'primaryLanguage': 'Python', 'stars': 0, 'readme': '# 2023-Fall-Hackathon\nThis is our submission for the KSU Fall 2023 hackathon.\n'}, {'name': 'aiATL2023', 'files': [{'name': '__init__.py', 'language': None, 'contents': ''}, {'name': 'evaluator.py', 'language': 'Python', 'contents': '# We want two evaluator functions: \n#   The meta-evaluator that interacts with the UI\n#       - Interacts with granular evaluator to compile granular summaries into \n#       higher level summary\n#       - Outputs higher level summary to UI\n#   A more granular evaluator that takes in and evaluates a skill\n#       - Loops through relevant github files\n#       - Outputs evaluations to meta-evaluator\n\nfrom google.cloud import aiplatform\nfrom langchain.llms import VertexAI\nfrom langchain.prompts import PromptTemplate\nfrom langchain.chains import LLMChain\nfrom langchain.chains import MapReduceDocumentsChain, ReduceDocumentsChain, StuffDocumentsChain\nfrom langchain.text_splitter import CharacterTextSplitter\n## DocumentLoaders and TextSplitters are not included here. These are super useful to process/chunk large inputs into prompts\n\n#Setup VertexAI model for langchain\nllm = VertexAI(model_name="code-bison",max_output_tokens=1000,temperature=0.3)\n\n# Map Step 1: file -> file description\nfile_map_template \n#\n# Reduce Step 1: file descriptions -> repo description\n\n# Reduce Step 2: Repo descriptions -> candidate description\n\ndef meta_eval(descriptions, skills):\n    # Map step: file descriptions -> repository description\n    # This basically asks for all of the file descriptions at once -- prob inefficient\n    # Need to specify delimiting character betweeen files and some format for name, language, etc. of a file\n    repo_map_template = """You are a technical hiring manager trying to judge the skills and quality of a candidate.\n    Your direct report has produced this set of descriptions of files within this candidates git repository. \n    Based on this list of reports, please summarize the quality of this repository and provide a detailed overview of the code.\n    Think step by step. \n    ```\n    {descriptions}\n    ```\n    Helpful Summary: """\n    \n    map_prompt = PromptTemplate.from_template(map_template)\n    map_chain = LLMChain(llm=llm,prompt=map_prompt)\n\n    # Reduce step: repository descriptions -> Candidate evaluation\n    reduce_template = """You are a technical hiring manager trying to judge the capabilities of a candidate.\n    The following is a set of descriptions and judgements of various code repositories that the candidate has authored. \n    {repo_descriptions}\n    Take these and organize these into a final, consolidated judgement of this candidate\'s strenghts and weaknesses.\n    Compare the skills and weaknesses with the following list of skills from the candidate\'s resume.\n    {skills}\n    At the end of your description of the candidate, give your definitive recommendation on whether this candidate deserves an interview. \n    """\n\n    reduce_prompt = PromptTemplate(template=reduce_template,input_variables=["descriptions","skills"])\n    reduce_chain=LLMChain(llm=llm,prompt=reduce_prompt)\n\n    combine_documents_chain = StuffDocumentsChain(\n            llm_chain=reduce_chain, document_variable_name="repo_descriptions"\n    )\n\n    reduce_documents_chain = ReduceDocumentsChain(\n            combine_documents_chain=combine_documents_chain,\n            collapse_documents_chain=combine_documents_chain,\n            token_max=4000\n    )\n\n    map_reduce_chain = MapReduceDocumentsChain(\n            llm_chain=map_chain,\n            reduce_documents_chain=reduce_documents_chain,\n            document_variable_name="descriptions",\n            return_intermediate_steps=False\n    )\n\n    # Running the MapReduce Chain\n    evaluation = map_reduce_chain.run(doc_captions)\n    return evaluation\n\n\ndef granular_eval():\n    # Take each file, summarize and judge it\n    # get from Josue\n    pass\n\ndef get_skills():\n    # Get list of skills from resume\n    # Get from Christopher\n    pass\n'}, {'name': 'DocumentAI.py', 'language': 'Python', 'contents': 'from google.api_core.client_options import ClientOptions\nfrom google.cloud import documentai\nimport sys\nimport os\n\n\ndef scan_resume(): #Function takes scan.pdf file from /test_resume and returns DocumentAI string of contents\n    PROJECT_ID = "github-recruiter-405500"\n    LOCATION = "us"  # Format is \'us\' or \'eu\'\n    PROCESSOR_ID = "90d61cdc4cadeb91"  # Create processor in Cloud Console\n\n    # The local file in your current working directory\n    cwd = os.getcwd()\n    print({cwd})\n    FILE_PATH = f\'{cwd}/screener/document_scan/test_resume/JSandoval-Resume-10-18-23.pdf\'\n    # Refer to https://cloud.google.com/document-ai/docs/file-types\n    # for supported file types\n    MIME_TYPE = "application/pdf"   \n\n    # Instantiates a client\n    docai_client = documentai.DocumentProcessorServiceClient(\n        client_options=ClientOptions(api_endpoint=f"{LOCATION}-documentai.googleapis.com")\n    )\n\n    # The full resource name of the processor, e.g.:\n    # projects/project-id/locations/location/processor/processor-id\n    # You must create new processors in the Cloud Console first\n    RESOURCE_NAME = docai_client.processor_path(PROJECT_ID, LOCATION, PROCESSOR_ID)\n\n    # Read the file into memory\n    with open(FILE_PATH, "rb") as image:\n        image_content = image.read()\n\n    # Load Binary Data into Document AI RawDocument Object\n    raw_document = documentai.RawDocument(content=image_content, mime_type=MIME_TYPE)\n\n    # Configure the process request\n    request = documentai.ProcessRequest(name=RESOURCE_NAME, raw_document=raw_document)\n\n    # Use the Document AI client to process the sample form\n    result = docai_client.process_document(request=request)\n\n    document_object = result.document\n    print("Document processing complete.")\n    print(f"Text: {document_object.text}")\n    return document_object.text\n\nif __name__ == "__main__":\n    scan_resume()'}, {'name': '__init__.py', 'language': None, 'contents': ''}, {'name': 'main.py', 'language': 'Python', 'contents': '# General Control flow:\n#   Run UI, wait for user input\n#   Once we get a github username and resume:\n#       - Scan resume\n#       - Pull relevant github files\n#   Loop through skills, and evaluate code\n#   Pass output from granular evaluations to higher level evaluation\n#\n# Imports\n#from ui.streamlit_proto.py import generate_ui\nfrom document_scan.DocumentAI.py import scan_resume\n\ndef main():\n    scan_resume\n\nif __name__ == "__main__":\n    main()\n'}, {'name': '__init__.py', 'language': None, 'contents': ''}, {'name': 'streamlit_proto.py', 'language': 'Python', 'contents': 'import streamlit as st\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n#from screener.document_scan.DocumentAI.py import \n#from screener.codey.evaluator.py import \n\n## Dummy Data\nmodel_skill_scores = {"C++":9.5,\n"React":9.0,\n"Python":9.5,\n"Java":3.0,\n"JavaScript":5.0,\n"Django":1.0}\n\nskills_ls = list(model_skill_scores.keys())\nskill_scores = list(model_skill_scores.values())\nfake_summary = "Meet Chad Giga, the epitome of a Google Developer. Chad is a highly skilled and experienced software engineer with a passion for innovation and a knack for solving complex problems. He possesses a deep understanding of computer science fundamentals and is proficient in a variety of programming languages and technologies. Chad is also an excellent communicator and collaborator, making him an invaluable asset to any team."\n## End of Dummy Data\n\n# create form\nwith st.form("master_form"):\n    #Column Formatting\n    col1, col2 = st.columns(2,gap="medium")\n    submit_flag = False\n\n    with col1:\n        uploaded_resume = st.file_uploader(\'Choose your Resume file\',type="pdf")\n    ## transform PDF to bytes or StringIO to send to DocumentAI\n\n    with col2:\n    ###Write error message if non-valid github format\n        git_user = st.text_input(\'Git Username\',\'\',key=\'git\')\n        st.write(\'Repository url: \', "github.com/" + git_user)\n\n        submit_btn = st.form_submit_button("Submit Git")\n        if submit_btn and git_user:\n            st.write(\':green[Submition Successful]\')\n            submit_flag = True\n        elif submit_btn and not git_user:\n            st.write(\':red[Enter Git Username to Continue]\')\n\n    st.markdown("##")\n    # Send pdf info to Vertex AI here\n         #Convert to bytes or StringIO below\n        #bytes_data = uploaded_resume.getvalue()\n        #st.write(bytes_data)\n\n        # To convert to a string based IO:\n        #stringio = StringIO(uploaded_resume.getvalue().decode("utf-8"))\n        #st.write(stringio)\n\n        # To read file as string:\n        #string_data = stringio.read()\n        #st.write(string_data)\n\n    if submit_flag:\n        col3, col4 = st.columns(2)\n        with col3:\n            st.write("List of Skills found in resume")\n            for skill in skills_ls:\n                st.markdown(f"- {skill}")\n\n        st.markdown("##")\n\n        with col4:\n            y_pos = np.arange(len(skills_ls))\n            fig, ax = plt.subplots(figsize=(5,5))\n            hbars = ax.barh(y_pos,skill_scores, align=\'center\')\n            ax.set_yticks(y_pos, labels=skills_ls)\n            ax.invert_yaxis()  # labels read top-to-bottom\n            ax.set_xlabel(\'Score\')\n            ax.set_title(\'Skill Scoreboard\')\n            st.pyplot(fig)\n\n        st.markdown("##")\n\n        ## Candidate Summary\n        st.write(\'Candidate Summary \\n\')\n        # Generated summary string passed below\n        st.write(fake_summary)\n\n        st.markdown("##")\n    \n        ## Expander for Question-Answer BOT\n        expander = st.expander("Click to ask questions about Resume and Github")\n        with expander:\n            user_prompt = st.text_area("",placeholder="Ex. Does the candidate have experience in datacleaning?")\n        st.write(\'Mirror question test: \',user_prompt)\n'}, {'name': 'summarize.py', 'language': None, 'contents': ''}], 'primaryLanguage': 'Python', 'stars': 0, 'readme': '# aiATL2023'}]
print(type(test_dict))
